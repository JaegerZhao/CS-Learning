# 数据结构

[TOC]

## 一、线性表

### 1.1顺序表

1. 定义

```c
#define MaxSize 50

typedef struct{
	int num;
}ElemType;

//静态分配
typedef struct{
    ElemType data[MaxSize];
    int length;
}SqList;

//动态分配
typedef struct {
	ElemType* data;
	int MaxSize,length;
}SqList;
```

2. 初始化

```c
//初始化静态顺序表
void InitList(SqList& L) {
	for (int i = 0; i < Maxsize; i++) {
		L.data[i].num=-1;
	}
	L.length = 0;
}

#define InitSize 20
//初始化动态顺序表
void InitList(SqList& L) {
	L.data = (ElemType*)malloc(InitSize * sizeof(ElemType));
	L.length = 0;
	L.MaxSize = InitSize;
}
```

3. 插入

```c
//在顺序表L的第i（1<=i<=L.length+1）个位置插入新元素e
bool ListInsert(SqList &L,int i,ElemType e){
    if(i<1||i>L.length+1)
        return false;
    if(L.length>=MaxSize)
        return false;
    for(int j=L.length;j>=i;j--)
        L.data[j]=L.data[j-1];
    L.data[i-1]=e;
    L.length++;
    return true;
}
```

时间复杂度*O(n)*

最好情况：在表尾插入，时间复杂度 *O(1)*;	最坏情况：在表头插入，时间复杂度 *O(n)*;

4. 删除

```c
//删除顺序表中第i（1<=i<=L.length）个位置的元素
bool ListDelete(SqList &L,int i,ElemType &e){
    if(i<1||i>L.length)
        return false;
    e=L.data[i-1];
    for(int j=i;j<L.length;j++)
        L.data[j-1]=L.data[j];
    L.length--;
    return true;
}
```

时间复杂度*O(n)*

最好情况：在表尾删除，时间复杂度*O(1)*;	最坏情况：在表头删除，时间复杂度*O(n)*;

5. 查找

```c
//按位查找，在顺序表L中查找第i个元素，返回其元素值
ElemType GetElem(SqList L,int i){
    return L.Class[i-1];
}
//按值查找,在顺序表L中查找第一个元素值等于e的元素，返回其位序
int LocateElem(SqList L,Elemtype e){
    int i;
    for(i=0;i<L.length;i++){
        if(L.data[i]==e)
            return i+1;
    }
    return 0;
}
```

按位查找：时间复杂度*O(1)*	按值查找：时间复杂度*O(n)*

6. 增加动态分配顺序表长度

```c
//增加动态分配顺序表长度
void IncreaseSize(SqList &L, int len) {
	ElemType* p = L.data;
	L.data = (ElemType*)malloc((L.MaxSize + len) * sizeof(ElemType));
	for (int i = 0; i < L.length; i++) {
		L.data[i] = p[i];			//将原数组搬移到拓展后的数组
	}
	L.MaxSize = L.MaxSize + len;
	free(p);
}
```

### 1.2链表

#### 1.2.1单链表

1. 定义

​	用链式存储实现了线性结构；一个结点存储一个数据元素；各节点间的先后关系用一个指针表示。

```c
typedef struct LNode{
    ElemType data;
    struct LNode *next;
}LNode,*LinkList;
```

2. 建立

```c
//头插法
void List_HeadInsert(LinkList &L,ElemType e) {		
	LNode* s; 
	s = (LNode*)malloc(sizeof(LNode));
	s->data = e;
	s->next = L->next;
	L->next = s;
}

//尾插法
void List_TailInsert(LNode* &tail, ElemType e) {		
	LNode* s;
	s = (LNode*)malloc(sizeof(LNode));
	s->data = e;
	tail->next = s;
	tail = s;
	tail->next = NULL;
}
```

时间复杂度*O(n)*

3. 按序号查找结点值

```c
LNode* GetElem(LinkList L, int i) {		
    int j = 1;
    LNode* p = L->next;
    if (i == 1)return L;
    else if (i < 1)return NULL;
    while (p != NULL && j < i) {
        p = p->next;
        j++;
    }
    return p;
}
```

时间复杂度*O(n)*

4. 按值查找表结点

```c
LNode* LocateElem(LinkList L, ElemType e) {		
	LNode* p = L->next;
	while (p != NULL && p->data != e) {
		p = p->next;
	}
	return p;
}
```

时间复杂度*O(n)*

5. 插入结点

```c
//按位插入：单链表L的插入e到第i位
bool ListInsert(LinkList& L, int i, ElemType e) {		
	LNode* p;
	if (i == 1) { p = L; }
	else {
		p = GetElem(L, i - 1);	//查找到前驱结点
		if (p == NULL)
			return false;
	}
	LNode* s = (LNode*)malloc(sizeof(LNode));
	s->data = e;
	s->next = p->next;
	p->next = s->next;
	return true;
}
```

时间复杂度*O(n)*

```c
//后插操作：在p结点后插入元素e
bool InsertNextNode(LNode* p, ElemType e) {
	if (p == NULL) 
		return false;
	LNode* s = (LNode*)malloc(sizeof(LNode));
	if (s == NULL)	//内存分配失败
		return false;
	s->data = e;
	s->next = p->next;
	p->next = s;
	return true;
}

//前插操作：在p结点之前插入元素e <偷天换日：将p结点的值赋给后插元素e，修改p结点的值>
bool InsertPriorNode(LNode* p, ElemType e) {
	if (p == NULL)
		return false;
	LNode* s = (LNode*)malloc(sizeof(LNode));
	if (s == NULL)
		return false;
	s->data = p->data;
	s->next = p->next;
	p->next = s;
	p->data = e;
	return true;
}
```

时间复杂度O(1)

6. 删除结点

```c
//按位删除：删除单链表L第i个结点，并将数据存于e中
bool ListDelete(LinkList& L, int i, ElemType & e) {
	if (i < 1)
		return false;
	LNode* p;
	p = L;
	int j = 0;
	while (p != NULL && j < i - 1) {
		p = p->next;
		j++;
	}
	if (p == NULL)
		return false;
	if (p->next == NULL)
		return false;
	LNode* q = p->next;
	p->next = q->next;
	e = q->data;
	free(q);
	return true;
}
```

时间复杂度*O(n)*

```c
//删除指定结点p <偷天换日:将后继结点的值赋予自己，删除后继结点> 
bool DeleteNode(LNode* p) {
	if (p == NULL)
		return false;
	if (p->next == NULL)	//对最后一个结点无效
		return false;
	LNode* q = p->next;
	p->next = q->next;
	p->data = q->data;
	free(q);
	return true;
}
```

时间复杂度*O(1)*

#### 1.2.2双链表

​	双链表结点中有两个指针prior和next，分别指向前驱和后继结点。

1. 定义

```c
typedef struct DNode {
	ElemType data;
	struct DNode* prior, * next;
}DNode,*DLinkList;
```

2. 初始化

```c
//初始化双链表
bool InitDLinkList(DLinkList& L) {
	L = (DNode*)malloc(sizeof(DNode));
	if (L = NULL)	//内存不足分配失败
		return false;
	L->prior = NULL;
	L->next = NULL;
	return true;
}
```

3. 插入

```c
//双链表插入:在p结点后插入s结点
bool InsertNextDNode(DNode* p, DNode* s) {
	if (p == NULL || s == NULL)
		return false;
	s->next = p->next;
	if (p->next != NULL)
		p->next->prior = s;
	s->prior = p;
	p->next = s;
	return true;
}
```

第5、7行一定要在8、9行前。

4. 删除

```c
//双链表删除:删除p的后继结点
bool DeleteNextDNode(DNode* p) {
	if (p == NULL)
		return false;
	DNode* q = p->next;
	if (q == NULL)		//p没有后继
		return false;
	p->next = q->next;
	if (q->next != NULL)		//q结点不是最后一个结点
		q->next->prior = p;
	free(q);
	return true;
}

//双链表删除:删除p的前驱结点
bool DeletePriorDNode(DNode* p) {
	if (p == NULL)
		return false;
	DNode* q = p->prior;
	if (q == NULL||q == L)		//p没有前驱或q为头结点
		return false;
	p->prior = q->prior;
	q->prior->next = p;
	free(q);
	return true;
}
```

5. 销毁

```c
//销毁双链表
void DestoryList(DLinkList& L) {
	while (L->next != NULL)
		DeleteNextDNode(L);
	free(L);	//释放头结点
	L = NULL;	//头指针指向NULL
}
```

#### 1.2.3循环链表

循环单链表：①空表时，头结点指针指向自己；②非空表时，尾结点指针指向头结点

循环双链表：①空表时，头结点next指针和prior指针都指向自己；②非空表时，头结点prior指针指向尾结点，尾结点next指针指向头结点

1. 初始化循环链表

```c
//初始化循环单链表
bool InitList(LinkList& L) {
	L = (LNode*)malloc(sizeof(LNode));
	if (L == NULL)		//内存不足分配失败
		return false;
	L->next = L;
	return true;
}
```

2. 判断循环链表是否为空

```c
//判断循环单链表是否为空
bool Empty(LinkList L) {
	if (L->next == L)
		return true;
	else
		return false;
}
```

3. 判断结点p是否为训练表的表尾结点

```c
//判断结点p是否为循环单链表的表尾结点
bool isTail(LinkList L, LNode* p) {
	if (p->next == L)
		return true;
	else
		return false;
}
```

#### 1.2.4静态链表

​	静态链表借助数组来描述线性表的链式存储结构，有数据域data和指针域next，指针存放的下个结点的数组下标，又称游标。文件系统中FAT表用静态链表存储文件信息。

​	优点：增、删操作不需要大量移动元素

​	缺点：不能随机存取，只能从头结点开始依次往后查找；容量固定不可变

1. 定义

```c
#define MaxSize 10		//静态链表的最大长度
typedef struct {		//静态链表结构类型的定义
	int data;			//存储数据元素
	int next;			//下一个元素数组坐标
}SLinkList[MaxSize];
```



## 二、栈

​	一种操作受限的线性表，只能在栈顶插入、删除；后进先出。

​	栈顶（Top）允许进行插入、删除的那一端；栈底（Bottom）固定的，不允许进行插入、删除的那一端。

### 2.1顺序栈

1. 定义

```c
#define MaxSize 10
typedef struct {		//定义顺序栈
	Elemtype data[MaxSize];	//静态数组存放栈中元素
	int top;			//栈顶指针
}SqStack;
```

2. 初始化栈

```c
//初始化栈
void InitStack(SqStack& S) {
	S.top = -1;
}
```

3. 栈判空

```c
//判断栈空
bool StackEmpty(SqStack S) {
	if (S.top == -1)
		return true;
	else
		return false;
}
```

4. 进栈

```c
//进栈：当栈不满时，top先+1，再入栈
bool Push(SqStack& S, ElemType x) {
	if (S.top == MaxSize - 1)	//栈满报错
		return false;
	/*S.top = S.top + 1;		//指针先加1
	S.data[S.top] = x;			//新元素入栈
	↓等价↓*/
	S.data[++S.top] = x;
	return true;
}
```

5. 出栈

```c
//出栈：当栈非空时，元素先出栈，top再-1
bool Pop(SqStack& S, ElemType& x) {
	if (S.top == -1)
		return false;
	/*x = S.data[S.top];
	S.top = S.top - 1;*/
	x = S.data[S.top--];
	return true;
}
```

6. 读栈顶元素

```c
//读取栈顶元素
bool GetTop(SqStack& S, ElemType& x) {
	if (S.top == -1)
		return false;
	x = S.data[S.top];
	return true;
}
```

### 2.2共享栈

​	两个栈共享同一片内存空间，两个栈从两边往中间增长。

1. 定义

```c
//共享栈
typedef struct {
	ElemType data[MaxSize];	//静态数组存放栈中元素
	int top0;
	int top1;
}ShStack;
```

2. 初始化

```c
//初始共享栈
void InitShStack(ShStack& S) {
	S.top0 = -1;
	S.top1 = MaxSize;
}
```

3.判空

```c
//共享栈判空:输入要判断的共享栈序号，若栈空返回1，非空返回0，输入非法返回-1
int ShStackEmpty(ShStack S,int num) {
	if (num == 0)
		return S.top0 == -1;
	else if(num == 1)
		return S.top1 == MaxSize;
    else return -1;
}
```

4. 判满

```c
//共享栈判满
bool ShStackFull(ShStack S){
    if(S.top1 - S.top0 == 1)
        return true;
    else return false;
}
```

5. 进栈

```c
//共享栈进栈
bool ShPush(ShStack& S, ElemType x, int num) {
	if (ShStackFull(S))	//栈满报错
		return false;
	if(num == 0)
        S.data[++S.top0] = x;
    else if(num == 1)
        S.data[--S.top1] = x;
    else return false;
	return true;
}
```

6. 出栈

```c
//共享栈出栈
bool ShPop(ShStack& S, ElemType& x, int num) {
	if (ShStackEmpty(S,num))
		return false;
	if(num == 0)
		x = S.data[S.top0--];
    else if(num == 1)
        x = S.data[S.top0++];
    else return false;
	return true;
}
```

### 2.3链栈

​	用链式存储方式实现的栈，一般用不带头结点的链式存在，栈顶Top在头结点。

1. 定义

```c
//链栈
typedef struct Linknode {
	ElemType data;					//数据域
	struct Linknode* next;		//指针域
}*LiStack;						//栈类型定义
```

2. 入栈

```c
//链栈入栈
LiStack LiPush(LiStack stack,ElemType x){
    //创建存储新元素的节点
    LiStack line=(LiStack*)malloc(sizeof(LiStack));
    line->data=x;
    //新节点与头节点建立逻辑关系
    line->next=stack;
    //更新头指针的指向
    stack=line;
    return stack;
}
```

3. 出栈

```c
//链栈出栈
LiStack LiPop(LiStack stack,ElemType &x){
    if(stack){
        LiStack p=stack;
        x=p.data;
        stack=stack->next;
        free(p);
    }
    return stack;
}
```

## 三、队列

​	一种操作受限的线性表，只能在队尾插入、在队头删除。先进先出。

​	队头（Front）允许删除的一端。队尾（Rear）允许插入一端。

### 3.1顺序存储

​	分配一块连续的存储单元存放队列中的元素，并附有两个指针，队头指针front指向队头元素，队尾指针rear指向队尾元素的下一个位置。

1. 定义

```c
#define MaxSize 10		//定义队列中元素的最大个数
typedef struct {
	ElemType data[MaxSize];	//用静态数组存放队列元素
	int front, rear;	//队头指针和队尾指针
}SqQueue;
```

存在上溢出，是一种假溢出。

### 3.2循环队列

​	用模运算（取余）将存储空间在逻辑上变为“环状"。

> ​	队尾指针进1：Q.rear=(Q.rear+1)%MaxSize；队首指针进1：Q.front=(Q.front+1)%MaxSize;
> ​	初始时：Q.front=Q.rear=0；队列长度：(Q.rear+MaxSize-Q.front)%MaxSize;

区分队满队空：
①牺牲一个单元：约定队头指针在队尾指针的下一个位置作为队满的标志；队满：(Q.rear+1)%MaxSize= =Q.front
②增设表示元素个数的成员size：队空Q.size= =0；队满Q.size= =MaxSize；
③增设tag成员表示删除、插入操作：Q.front= =Q.rear时，tag= =0因删除导致，队空；tag= =1因插入导致，队满

1. 初始化

```c
//初始化队列
void InitQueue(SqQueue& Q) {
	Q.rear = Q.front = 0;
}
```

2. 判队空

```c
//判队空
bool isEmpty(SqQueue Q){
    if(Q.rear == Q.front) return true;
    else return false;
}
```

3. 入队

```c
//入队
bool EnQueue(SqQueue& Q, ElemType x) {
	if ((Q.rear + 1) % MaxSize == Q.front)	//队满
		return false;
	Q.data[Q.rear] = x;
	Q.rear = (Q.rear + 1) % MaxSize;		//循环队列
	return true;
}
```

4. 出队

```c
//出队
bool DeQueue(SqQueue& Q, ElemType& x) {
	if (Q.rear == Q.front)				//队空
		return false;
	x = Q.data[Q.front];
	Q.front = (Q.front + 1) % MaxSize;
	return true;
}
```

5. 查找

```c
//查：获取队头元素
bool GetHead(SqQueue Q, ElemType& x) {
	if (Q.rear = Q.front)
		return false;
	x = Q.data[Q.front];
	return true;
}

//查：队列长度
void LengthQueue(SqQueue Q, int& length) {
	length = (Q.rear + MaxSize - Q.front) % MaxSize;
}
```

### 3.3链式队列

​	带有队头指针和队尾指针的单链表；头指针指向队头结点，尾指针指向队尾结点（与顺序存储不同，是最后一个结点）。一般设计为带头结点的单链表。不存在队列满与产生溢出的问题。

1. 定义

```c
//链式队列结点
typedef struct LinkNode {		
	ElemType data;
	struct LinkNode* next;
}LinkNode;
//链式队列
typedef struct {				
	LinkNode* rear, * front;	//队列队头队尾指针
	//int length;
}LinkQueue;
```

2. 初始化

```c
//初始化队列（带头节点）
void InitQueue(LinkQueue& Q) {
	//初始化front、rear都指向头结点
	Q.front = Q.rear = (LinkNode*)malloc(sizeof(LinkNode));
	Q.front->next = NULL;
}
```

3. 判队空

```c
//判断队列是否为空
bool IsEmpty(LinkQueue Q) {
	if (Q.front = Q.rear) return true;
	else return false;
}
```

4. 入队

```c
//入队
void EnLQueue(LinkQueue& Q, ElemType e) {
	LinkNode* s = (LinkNode*)malloc(sizeof(LinkNode));
	s->data = e;
	s->next = NULL;
	Q.rear->next = s;
	Q.rear = s;
}
```

5. 出队

```c
//出队
bool DeLQueue(LinkQueue& Q, ElemType& e) {
	if (Q.front == Q.rear)		//队空
		return false;
	LinkNode* p = Q.front->next;
	e = p->data;
	Q.front->next = p->next;
	if (Q.rear == p)			//删除元素后队空
		Q.rear = Q.front;
	free(p);
	return true;
}
```

### 3.4双端队列

​	允许从两端插入、两端删除的队列。
​	输入受限的双端队列：允许从两端删除、从一端插入的队列；
​	输出受限的双端队列：允许从两端插入、从一端删除的队列。

### 3.5栈和队列的应用

#### 3.5.1括号匹配

​	算法思想：依次扫描所有字符，遇到左括号入栈，遇到右括号则弹出栈顶元素检查是否匹配。
​	匹配失败：①左括号单身；②右括号单身；③左右括号不匹配

```c
//括号匹配检验
bool bracketCheck(char str[], int length) {
	SqStack S;
	InitStack(S);			//初始化一个栈
	for (int i = 0; i < length; i++) {
		if (str[i] == '(' || str[i] == '[' || str[i] == '{') {
			Push(S, str[i]);		//扫描到左括号，入栈
		}
		else if(str[i] == ')' || str[i] == ']' || str[i] == '}')
		{
			if (StackEmpty(S))		//扫描到右括号，且当前栈空
				return false;		//匹配失败
			char topElem;
			Pop(S, topElem);		//栈顶元素出栈
			if (str[i] == ')' && topElem != '(')
				return false;
			if (str[i] == ']' && topElem != '[')
				return false;
			if (str[i] == '}' && topElem != '{')
				return false;
		}
	}
	return StackEmpty(S);		//检索完全括号后，栈空说明匹配成功
}
```

#### 3.5.2表达式求值

三种算术表达式：

- 中缀表达式：运算符在两个操作数中间；a+b-c*d
- 后缀表达式：运算符在两个操作数后面；ab+cd*-
- 前缀表达式：运算符在两个操作数前面；-+ab*cd

##### 用栈实现中缀表达式转后缀表达式

1. 初始化一个栈，用于保存暂时还不能确定运算顺序的运算符。

2. 从左到右处理各个元素，直到末尾。可能遇到三种情况：

   ​		① 遇到**操作数**。直接加入后缀表达式。

   ​		② 遇到**界限符**。遇到“(”直接入栈；遇到“)”则依次弹出栈内运算符并加入后缀表达式，直到弹出“(”为止。
   ​			注意：“(”不加入后缀表达式。

   ​		③ 遇到**运算符**。依次弹出栈中***优先级高于或等于***当前运算符的所有运算符，并加入后缀表达式，若碰到“(” 或栈空则停止。之后再把当前运算符入栈。

3. 按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式

> 中缀转前缀：从右往左处理；遇到")"入栈，遇到"("依次弹出栈内运算符直到弹出")"；遇到运算符，只弹出优先级高于当前运算符的运算符，处理完逆置

##### 用栈实现后缀表达式的计算

​	①从左往右扫描下一个元素，直到处理完所有元素
​	②若扫描到操作数则压入栈，并回到①；否则执行③
​	③若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到①

##### 用栈实现中缀表达式的计算

1. 初始化两个栈，操作数栈和运算符栈
2. 若扫描到操作数，压入操作数栈
3. 若扫描到运算符或界限符，则按照“中缀转后缀”相同的逻辑压入运算符栈（期间也会弹出运算符，每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈)

#### 3.5.3递归

​	在一个函数、过程或数据结构的定义中，又应用了它自身，则其是递归的。

1. 递归程序

​	递归模型不能循环定义，必须有①递归表达式（递归体）；②边界条件（递归出口）

​	*递归精髓在于能否将原始问题转换为属性相同但规模较小的问题。*

```c
//斐波那契数列实现
int Fib(int n){
    if(n == 0)
        return 0;					//边界条件
    else if(n==1)
        return 1;					//边界条件
    else
        return Fib(n-1)+Fib(n-2);	//递归表达式
}
```

​	递归效率低下，但代码简单。将递归算法转换为非递归算法需要借助栈来实现。

2. 函数调用栈

​	工作模式：

- 递归调用时，函数调用栈可称为“递归工作栈”
- 每进入一层递归，就将递归调用所需信息压入栈顶
- 每退出一层递归，就从栈顶弹出相应信息

#### 3.5.4队列应用

​	层次遍历

​	数据缓冲区、操作系统阻塞队列、就绪队列。

#### 3.5.6特殊矩阵

1. 对称矩阵

<img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221115161658884.png" alt="image-20221115161658884" style="zoom:80%;" />

特点：对方阵中的任意一个元素，有ai，j=aj，i
压缩：只存储主对角线+下三角区（或主对角线+上三角区）

2. 三角矩阵

<img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221115161759545.png" alt="image-20221115161759545" style="zoom:80%;" />

特点：上三角区全为常量（下三角矩阵）；或下三角区全为常量（上三角矩阵）
压缩：按行优先/列优先规则依次存储非常量区域，并在最后一个位置存放常量c

3. 三对角矩阵

<img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221115161833784.png" alt="image-20221115161833784" style="zoom:80%;" />

特点：当|i-j|>1时，有ai,j=0（1≤i，j≤n）
压缩：按行优先/列优先规则依次存储带状区域

4. 稀疏矩阵

<img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221115161912985.png" alt="image-20221115161912985" style="zoom:80%;" />

特点：非零元素个数远小于零元素个数
压缩：只存储非零元素；①顺序存储：顺序存储**三元组<行，列，值>**；②链式存储：**十字链表法**

## 四、串

### 4.1串的定义

​	串（string）是由零个或多个字符组成的有限序列。

1. 定长顺序存储

```c
#define MAXLEN 255
typedef struct {
	char ch[MAXLEN];
	int length;
}SString;		//静态数组实现
```

2. 堆分配存储表示

```c
typedef struct {
	char* ch;
	int length;
}HString;		//动态数组实现
```

3. 块链存储表示

```c
//链式存储
typedef struct {
	char ch[4];		//每个结点存多个字符
	struct StringNode* next;
}StringNode,*String;
```

### 4.2串的模式匹配

#### 4.2.1朴素模式匹配

​	子串的定位操作通常称为串的模式匹配，它求的是子串（常称模式串）在主串中的位置。

```c
//不依赖于其他串操作的暴力匹配算法
int Index(SString S, SString T) {
	int i = 1;
	while (i <= S.length&&j<=T.length) {
		if(S.ch[i]==T.ch[j]){
            ++i;++j;			//继续比较后续字符
        }
        else{
         i=i-j+2;j=1;			//指针后退重新开始匹配   
        }
        if(j>T.length)return i-T.length;
        else return 0;
}
```

​	在上述算法中，分别用计数指针i和j指示主串S和模式串T中当前正待比较的字符位置。算法思想为：
​	从主串S的第一个字符起，与模式T的第一个字符比较，若相等，则继续逐个比较后续字符；否则从主串的下一个字符起，重新和模式的字符比较；以此类推，直至模式T中的每个字符依次和主串S中的一个连续的字符序列相等，则称匹配成功，函数值为与模式T中第一个字符相等的字符在主串S中的序号，否则称匹配不成功，函数值为零。

时间复杂度：若模式串长度为m，主串长度为n，则直到匹配成功/匹配失败最多需要（n-m+1）*m次比较

最坏时间复杂度：O（nm）

#### 4.2.2KMP算法

​	朴素模式匹配算法需要大量对主串的回退，减慢了算法速度。KMP算法通过回退子串，来使得主串不回退；引用next数组，包含当判断到子串某一个字符最优的回退位置。

1. 算法思想：

- 建立哨兵i遍历主串，j遍历子串
- 当i、j遍历的字符不匹配，令j保持首字符位置，增加i的值遍历主串
- 当i、j字符匹配时，同时增加i、j的值继续判断是否匹配
- 若遍历到不匹配的值，令j回退到next数组装载的合适回退点，主串i继续向后遍历
- 直到j的值大于子串长度，匹配成功，返回i减去子串长度的值，为模式串位置
- 若i大于主串的长度，匹配失败，返回0

2. next数组

​	串的前缀：包含第一个字符，且不包含最后一个字符的子串
​	串的后缀：包含最后一个字符，且不包含第一个字符的子串

​	当第个字符匹配失败，由前1~j-1个字符组成的串记为s，则：**next[j]=S的最长相等前后缀长度+1**

<img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221122192302817.png" alt="image-20221122192302817" style="zoom:67%;" />

```c
//求next数组
void get_next(String T,int next[]){
    int i=1,j=0;
    next[1]=0;
    while(i<T.length){
        if(j==0||T.ch[i]==T.ch[j]){
            ++i;++j;
            next[i]=j;		//若pi=pj,则next[j+1]=next[j]+1
        }
        else j=next[j];		//否则令j=next[j]，循环继续
    }
}
//KMP算法
int Index_KMP(String S, String T, int next[]) {
	int i = 1, j = 1;
	while (i <= S.length && j <= T.length) {
		if (j == 0 || S.ch[i] == T.ch[j]) {
			++i;
			++j;				//继续比较后继字符
		}
		else j = next[j];		//模式串向右移动
	}
	if (j > T.length)
		return i - T.length;	//匹配成功
	else
		return 0;
}

```

3. 时间复杂度 O（m+n）

#### 4.2.3KMP算法优化以及nextval数组

​	解决KMP算法，重新匹配的字符与模式串第一个字符相同时，退回后多做一次匹配的问题。

​	算法思想：模式串有相同字符时，后一个字符值替换成前一个字符的next值

<img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221122192421331.png" alt="image-20221122192421331" style="zoom: 50%;" /><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221122192531039.png" alt="image-20221122192531039" style="zoom: 33%;" />

```c
//求nextval数组
void get_nextval(String T,int nextval[]){
    int i=1,j=0;
    nextval[1]=0;
    while(i<T.length){
        if(j==0||T.ch[i]==T.ch[j]){
            ++i;++j;
            if(T.ch[i]!=T.ch[j])nextval[i]=j;
            else nextval[i]=nextval[j];
        }
        else j=nextval[j];		//否则令j=next[j]，循环继续
    }
}
```

​	KMP算法仅在主串与子串有很多“部分匹配”时才显得比普通算法快得多，其主要优点是主串不回溯。

## 五、树与二叉树

### 5.1树

#### 5.1.1树的定义

1. 双亲表示法

​	用连续空间存储每个结点，同时在每个结点增设一个伪指针，指示其双亲结点在数组中的位置。

​	优点：找父节点方便；缺点：找孩子不方便

```c
#define MAX_TREE_SIZE 100		//树中最多结点
//双亲表示法(顺序存储)
typedef struct {
	ElemType data;		//数据元素
	int parent;			//双亲位置域
}PTNode;
typedef struct {
	PTNode nodes[MAX_TREE_SIZE];		//双亲表示
	int n;								//结点数
}PTree;
```

2. 孩子表示法

​	将每个结点的孩子结点都用单链表链接起来形成一个线性结构，此时n个结点就有n个孩子链表（叶子结点的孩子链表为空表）。

​	优点：找孩子方便；缺点：找父节点不方便

```c
//孩子表示法（顺序+链式）
struct CTNode {
	int child;					//孩子结点在数组中的位置
	struct CTNode* next;		//下一个孩子
};
typedef struct {
	ElemType data;
	struct CTNode* firstChild;	//第一个孩子
}CTBox;
typedef struct {
	CTBox nodes[MAX_TREE_SIZE];
	int n, r;					//结点数和根的位置
}CTree;
```

3. 孩子兄弟表示法

​	又称二叉树表示法，用二叉链表存储树——左孩子右兄弟。孩子兄弟表示法存储的树，从存储视角来看形态上和二又树类似；树与二叉树的相互转换。本质就是用孩子兄弟表示法存储树。

```c
//孩子兄弟表示法(链式存储)
typedef struct CSNode {
	ElemType data;								//数据域
	struct CSNode* firstchild, * nextsibling;	//第一个孩子和右兄弟指针
}CSNode, * CSTree;
```

#### 5.1.2树的遍历

1. 先根遍历

​	若树非空，则先访问根结点，再依次遍历根结点的每颗子树，遵循先根后子树的规则。

​	遍历序列与这棵树相应二叉树的**先序序列**相同。

```c
//树的先根遍历
void PreOrder(TreeNode* R) {
	if (R != NULL) {
		visit(R);
		while (R还有下一个子树T)
			PreOrder(T);
	}
}
```

2. 后根遍历

​	若树非空，则先依次遍历根结点的每颗子树，再访问根结点，遵循先子树后根的规则。

​	遍历序列与这棵树相应二叉树的**中序序列**相同。

```c
//树的后根遍历
void PostOrder(TreeNode* R) {
	if (R != NULL) {
		while (R还有下一个子树T)
			PostOrder(T);
        visit(R);
	}
}
```

### 5.2二叉树

#### 5.2.1二叉树存储结构

1. 顺序存储

​	从数组下标1开始存储树中结点，可以根据下标i的⌊i/2⌋算出双亲结点位置，2i为左孩子，2i+1为右孩子

```c
//顺序存储的二叉树，适合完全二叉树和满二叉树
#define MaxSize 100
struct TreeNode {
	int value;		//结点中的数据元素
	bool isEmpty;	//结点是否为空
};
TreeNode t[MaxSize];
```

2. 链式存储

```c
//链式存储的二叉树
typedef struct BiTNode {
	ElemType data;							//数据域
	struct BiTNode* lchild, * rchild;	//左右孩子指针
	//struct BiTNode* parent;
}BiTNode, * BiTree;
BiTree root = NULL;			//定义一颗空树
```

3. 链式存储结点的插入

```c
//插入根节点
void enTree() {
	root = (BiTree)malloc(sizeof(BiTNode));
	root->data = { 1 };
	root->lchild = NULL;
	root->rchild = NULL;
}

//插入新结点
void inTNode() {
	BiTNode* p = (BiTNode*)malloc(sizeof(BiTNode));
	p->data = { 2 };
	p->lchild = NULL;
	p->rchild = NULL;
	root->lchild = p;		//作为根节点的左孩子
}
```

#### 5.2.2二叉树的遍历

1. 先序遍历（根左右）

```c
//先序遍历
void PreOrder(BiTree T) {
	if (T != NULL) {
		visit(T);
		PreOrder(T->lchild);
		PreOrder(T->rchild);
	}
}
```

​	非递归算法：

```c
void PreOrder2(BiTree T){
    InitStack(S);BiTree p=T;
    while(p||!IsEmpty(S)){
        if(p){
            visit(p);
            Push(S,p);
            p=p->lchild;
        }
        else{
            Pop(S,p);
            p=p->rchild;
        }
    }
}
```

2. 中序遍历（左根右）

```c
//中序遍历
void InOrder(BiTree T) {
	if (T != NULL) {
		InOrder(T->lchild);
		visit(T);
		InOrder(T->rchild);
	}
}
```

​	非递归算法：

```c
void InOrder2(BiTree T){
    InitStack(S);BITree p=T;
    while(p||!IsEmpty(S)){
        if(p){
            Push(S,p);
            p=p->lchild;
        }
        else{
            Pop(S,p);visit(p);
            p=p->rchild;
        }
    }
}
```

3. 后序遍历（左右根）

```c
//后序遍历
void PostOrder(BiTree T) {
	if (T != NULL) {
		PostOrder(T->lchild);
		PostOrder(T->rchild);
		visit(T);
	}
}
```

​	非递归算法：

​	从根结点起，将其入栈，然后沿其左子树一直往下搜索，直到没有左孩子结点，若其有右子树，再重复上述动作。直至上述操作进行不下去，若栈顶元素想要出栈访问，要么右子树为空，要么右子树刚被访问完。

```c
void PostOrder2(BiTree T){
    InitStack(S);BiTNode *p=T, *r=NULL;
    while(p||!IsEmpty(S)){
        if(p){							//走到最左边
            Push(S,p);
            p=p->lchild;
        }
        else{							//向右
            GetTop(S,p);				//读栈顶元素（非出栈）
            if(p->rchild&&p->rchild!=r)	//若右子树存在，且未被访问
                p=p->rchild;
            else{
                Pop(S,p);
                visit(p);				
                r=p;					//记录最近访问过的结点
                p=NULL;					//结点访问完，重置p结点
            }
        }//else
    }//while
}
```

4. 层次遍历

​	①初始化一个辅助队列
​	②根结点入队
​	③若队列非空，则队头结点出队，访问该结点，并将其左、右孩子插入队尾（如果有的话）
​	④重复③直到队列空

```c
//层次遍历
void LevelOrder(BiTree T) {
	LinkQueue Q;
	InitQueue(Q);
	BiTree p;
	EnQueue(Q,T);
	while (!IsEmpty(Q)) {
		DeQueue(Q, p);
		visit(p);
		if (p->lchild != NULL)
			EnQueue(Q, p->lchild);
		if (p->rchild != NULL)
			EnQueue(Q, p->rchild);
	}
}
```

#### 5.2.3线索二叉树

充分利用空指针域，方便从一个指定结点出发，找到其前驱、后继；方便遍历

1. 线索二叉树存储结构

```c
//线索二叉树结点
//tag=0,表示指针指向孩子，tag=1,表示指针指向线索
typedef struct ThreadNode {
	ElemType data;							//数据域
	struct ThreadNode* lchild, * rchild;	//左右孩子指针
	//struct BiTNode* parent;
	int ltag, rtag;							//左右线索标准
}ThreadNode, * ThreadTree;
```

2. 线索化访问

```c
//全局变量pre,指向当前访问结点的前驱
ThreadNode* pre = NULL;

//线索化访问
void Tvisit(ThreadNode* q) {
	if (q->lchild == NULL) {
		q->lchild == pre;
		q->ltag = 1;
	}
	if (pre != NULL && pre->rchild == NULL) {
		pre->rchild = q;
		pre->rtag = 1;
	}
	pre = q;
}
```

3. 中序线索化二叉树

![image-20221116191058964](https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221116191058964.png)

```c
//中序遍历二叉树，一边遍历一边线索化
void InThread(ThreadTree T) {
	if (T != NULL) {
		InThread(T->lchild);
		Tvisit(T);
		InThread(T->rchild);
	}
}

//中序线索化二叉树
void CreateInTehread(ThreadTree T) {
	pre = NULL;
	if (T != NULL) {
		InThread(T);
		if (pre->rchild == NULL)
			pre->rtag = 1;			//处理遍历的最后一个结点
	}
}
```

先序线索化二叉树

![image-20221116191931008](https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221116191931008.png)

```c
//先序遍历二叉树，一边遍历一边线索化
void PreThread(ThreadTree T) {
	if (T != NULL) {
		Tvisit(T);
		if(T->ltag=0)				//lchild不是前驱线索
			PreThread(T->lchild);
		PreThread(T->rchild);
	}
}

//先序线索化二叉树
void CreatePreThread(ThreadTree T) {
	pre = NULL;
	if (T != NULL) {
		PreThread(T);
		if (pre->rchild == NULL)
			pre->rtag = 1;			//处理遍历的最后一个结点
	}
```

后序线索化二叉树

<img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221116191940074.png" alt="image-20221116191940074" style="zoom:50%;" />

```c
//后序遍历二叉树，一边遍历一边线索化
void PostThread(ThreadTree T) {
	if (T != NULL) {
		PostThread(T->lchild);
		PostThread(T->rchild);
		Tvisit(T);
	}
}

//后序线索化二叉树
void CreatePostThread(ThreadTree T) {
	pre = NULL;
	if (T != NULL) {
		PostThread(T);
		if (pre->rchild == NULL)
			pre->rtag = 1;			//处理遍历的最后一个结点
	}
}
```

4. 中序线索二叉树的遍历

​	先找到序列中第一个结点，然后一次找结点的后继，直到后继为空。
​	找后继：若其右标志为1，则右链为线索，指示其后继，否则遍历右子树中第一个访问的结点（右子树中最左下的结点）为其后继。

```c
//找到以P为根的子树中，第一个被中序遍历的结点
ThreadNode* FirstNode(ThreadNode* p) {
	while (p->ltag == 0)
		p = p->lchild;
	return p;
}

//在中序线索二叉树中找到结点p的后继结点
ThreadNode* NextNode(ThreadNode* p) {
	if (p->rtag == 0)
		return FirstNode(p->rchild);
	else return p->rchild;		//rtag==1直接返回后继线索
}

//对中序线索二又树进行中序遍历（利用线索实现的非递归算法）
void Inorder(ThreadNode* T) {
	for (ThreadNode* p = FirstNode(T); p != NULL; p = NextNode(p))
		Visit(p);
}
```

逆中序遍历：

```c
//找到以P为根的子树中，最后一个被中序遍历的结点
ThreadNode* LastNode(ThreadNode* p) {
	while (p->rtag == 0)
		p = p->rchild;
	return p;
}

//在中序线索二又树中找到结点p的前驱结点
ThreadNode* PreNode(ThreadNode* p) {
	if (p->ltag == 0)
		return LastNode(p->lchild);
	else
		return p->lchild;
}

//对中序线索二又树进行逆向中序遍历
void RevInorder(ThreadNode* T) {
	for (ThreadNode* p = LastNode(p); p != NULL; p = PreNode(p))
		Visit(p);
}
```

### 5.3森林

1. 先序遍历森林

​	若森林为非空，则按如下规则进行遍历：

- 访问森林中第一棵树的根结点。
- 先序遍历第一棵树中根结点的子树森林。
- 先序遍历除去第一棵树之后剩余的树构成的森林。

​	**与其转换的二叉树先序遍历相同**

2. 中序遍历

​	若森林为非空，则按如下规则进行遍历：

- 中序遍历森林中第一棵树的根结点的子树森林。
- 访问第一棵树的根结点。
- 中序遍历除去第一棵树之后剩余的树构成的森林。

​	**与其转换的二叉树中序遍历相同**

### 5.4并查集

![image-20221116193304811](https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221116193304811.png)

​	并查集是一种简单的集合表示，支持一下三种操作：

- Initial(S)：初始化并查集，将所有数组元素初始化为-1；每个元素初始化为只有一个单元素的子集合。
- Union(S[ ]，root1，root2)：“并”，将两个集合合并为一个集合；把集合S中的子集合Root2并入Root1。
- Find(S[ ]，x)：“查”，找到元素x所属集合，并返回该子集合根结点。

1. 定义并查集

```c
#define SIZE 13
int UFSets[SIZE];	//集合元素数组
```

2. 初始化并查集

```c
//初始化并查集
void Initial(int S[]) {
	for (int i = 0; i < SIZE; i++) {
		S[i] = -1;
	}
}
```

3. 查操作

```c
//Find “查”操作，找到x所属集合
int Find(int S[], int x) {
	while (S[x] >= 0)
		x = S[x];
	return x;
}
```

4. 并操作

```c
//Union “并”操作，将两个集合合并
void Union(int S[], int Root1, int Root2) {
	//要求Root1与Root2是不同的集合
	if (Root1 == Root2)return;
	//将根Root2连接到另一根Root1下面
	if (S[Root2] > S[Root1]) {		//减少树的高度
		S[Root1] += S[Root2];
		S[Root2] = Root1;
	}
	else {
		S[Root2] += S[Root1];
		S[Root1] = Root2;
	}
}
```

## 六、图

### 6.1存储方式

#### 6.1.1邻接矩阵法

​	使用一个一维数组存储图中顶点信息，用一个二维数组存储图中边的信息，存储顶点之间邻接关系的二维数组称为*邻接矩阵*。![image-20221117081642378](https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221117081642378.png)

```c
#define MaxVertexNum 100						//顶点数目的最大值
typedef char VertexType;						//顶点的数据类型
typedef int EdgeType;							//带权图边上权值的数据类型
typedef struct{
    VertexType Vex[MaxVertexNum];				//顶点表
    EdgeType Edge[MaxVertexNum][MaxVertexNum];	//邻接矩阵，边表
    int vexnum,arcnum;							//图的当前顶点数和弧数
}MGraph;
```

特点：

- 空间复杂度高，为O(n^2^)，不适合存储稀疏图，适合存储稠密图。
- 无向图的邻接矩阵一定是一个对称矩阵。实际存储只需存储上（下）三角矩阵的元素。
- 邻接矩阵容易确定图中任意两点是否有边相连，但确定图中有多少边，须按行、列遍历每个元素。
- 对于无向图，邻接矩阵的第i行（或第i列）非零元素（或非∞元素）的个数正好是顶点i的**度TD(v~i~)**
- 对于有向图，邻接矩阵的**第i行**非零元素（或非∞元素）的个数是顶点的**出度OD(v~i~)**；**第i列**非零元素（或非∞元素）的个数是顶点的**入度ID(v~i~)**
- 设图G的邻接矩阵为***A***，***A^n^***的元素***A^n^[i] [j]***等于由顶点i到顶点j的长度为n的路径的数目。

#### 6.1.2邻接表法

​	对图G中的每个顶点v~i~建立一个单链表，第i个单链表中的结点表示依附与顶点v~i~的边（对于有向图则是**以顶点v~i~为尾的弧**），则这个单链表就称为v~i~的*边表*（对于有向图则为*出边表*）。边表的头指针和顶点的数据信息采用顺序存储（称为*顶点表*）。

![image-20221117083641315](https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221117083641315.png)

```c
#define MaxVertexNum 100
//边表结点
typedef struct ArcNode {
	int adjvex;				//边、弧指向哪个结点
	struct ArcNode* next;	//指向下一条弧的指针
	//InfoType info;		//边权值
}ArcNode;
//顶点表结点
typedef struct VNode {
	VertexType data;		//顶点信息
	ArcNode* first;			//第一条边、弧
}VNode,AdjList[MaxVertexNum];
//用邻接表存储的图
typedef struct {
	AdjList vertices;		//邻接表：顶点数组
	int vexnum, arcnum;		//结点、边个数
}ALGraph;
```

特点：

- 若G为无向图，则所需存储空间为O(|V|+2|E|)；若G为有向图，则存储空间为O(|V|+|E|)。
  适合存储稀疏图。图的邻接表不唯一，取决于建表时算法以及边的输入次序。
- 在邻接表中，给定一顶点，很容易找到它的所有邻边。但是若要确定给点两点是否存在边，邻接矩阵可直接查到，而邻接表需要在相应结点对应边表查找。
- 在有向图的邻接表表述中，求一个顶点的出度只需计算其邻接表中的结点个数；但求其入度需要遍历全部邻接表。因此，也可采用逆邻接表的存储方式求解给定顶点入度。

#### 6.1.3十字链表

​	十字链表是***有向图***的一种链式存储结构。在十字链表中，有向图每条弧有一个结点，对用每个顶点也有一个结点。结点结构图如下所示。

<img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221117084914642.png" alt="image-20221117084914642" style="zoom:50%;" />

**弧结点：**
	尾域（tailvex）和头域（headvex）分别指示弧尾和弧头这两个顶点在图中的位置；
	链域hlink指向弧头相同的下一条弧，链域tlink指向弧尾相同的下一条弧；info域指向该弧的相关信息。

**顶点结点：**
	data域存放顶点相关的数据信息，如顶点名称；
	firstin和firstout两个域分别指向以该顶点为弧头或弧尾的第一个顶点。

![image-20221117085524655](https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221117085524655.png)

​	在十字链表中，既容易找到V~i~为尾的弧，又容易找到V~i~为头的弧。如上图所示，顺着绿色路线可找到该顶点所有出边，顺着橙色路径可以找到该顶点所有入边。容易求出顶点的出度和入度。

​	空间复杂度O(|V|+|E|)

#### 6.1.4邻接多重表

​	邻接多重表是***无向图***的一种链式存储结构。在邻接多重表中，每条边和每个顶点用一个结点表示。

![image-20221117090224204](https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221117090224204.png)

**边结点：**

​	mark为标志域，编辑该条边是否被搜索过；ivex和jvex为该条边依附的两个顶点在图中的位置；
​	Ilink指向下一条依附与顶点ivex的边；jlink指向下一条依附与顶点jvex的边；
​	info指向和边相关的信息的指针域。

**顶点结点：**

​	data域存储该顶点的相关信息；firstedge域指示第一条依附于该顶点的边。

![image-20221117090616830](https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221117090616830.png)

​	对于无向图而言，邻接多重表与邻接表的差别在于，同一条边在邻接表中用两个结点表示，在邻接多重表中只有一个结点。

### 6.2图的遍历

#### 6.2.1广度优先搜索BFS

##### 算法思想

​	广度优先类似于二叉树的层次遍历。基本思想是：首先访问起始顶点v，接着由v出发，依次访问v各个为访问过的邻接顶点w1，w2…wi，然后再次访问w1，w2…wi的所有未被访问的邻接顶点，直到所有邻接顶点都被访问。若此时图中有仍未被访问的顶点，选择其中一个作为起始点，重复上述过程，直到图中所有顶点都被访问。

​	不是一个递归算法，为了实现逐层访问，需要借助一个辅助队列与一个访问标记数组。

```c
bool visited[MAX_VERTEX_NUM];			//访问标记数组
void BFSTraverse(Graph G){				//对图G进行广度优先遍历
    for(int i;i<G.vexnum;++i)
        visited[i]=FALSE;				//初始化访问标记数组
    InitQueue(Q);						//初始化辅助队列Q
    for(int i=0;i<G.vexnum;++i)			//从0号顶点开始遍历
        if(!visited[i])					//对每个未被访问的结点进行BFS
            BFS(G,i);
}
void BFS(Graph G,int v){				//从顶点v除法，广度优先遍历图G
    visit(v);
    visited[v]=TRUE;					//标记v已被访问
    EnQueue(Q,v);						//顶点v入队
    while(!IsEmpty(Q)){	
        DeQueue(Q,v);					//顶点v出队
        for(w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w))	//检测所有v的邻接顶点
            if(!visited[w]){			//w为v的尚未访问的邻接顶点
                visit(w);
                visited[w]=TRUE;
                EnQueue(Q,w);
            }//if
    }//while
}
```

​	空间复杂度：需要借助辅助队列Q，n个顶点均需入队一次，空间复杂度O(V)；
​	时间复杂度：每个顶点均需搜索一次，每个边均需搜索一次，邻接表时间复杂度O(|V|+|E|)，邻接矩阵O(|V|^2^)

##### BFS求解最短路径问题

​	若图*G=(V,E)*为**非带权图**，定义从顶点u到顶点v的 *最短路径d(u,v)* 为从u到v的任何路径中最少的边数；若u到v没有通路，则d(u,v)=∞。

```c
void BFS_MIN_DIstance(Graph G,int u){
//d[i]表示从u到i结点的最短路径
    for(int i=0;i<G.vexnum;++i)
        d[i]=-1;						//-1代表无穷远，不可达
    visited[u]=TRUE;d[u]=0;
    EnQueue(Q,u);
    while(!IsEmpty(Q)){
        DeQueue(Q,u);
        for(w=FirstNeighbor(G,u);w>=0;w=NextNeighbor(G,u,w))	//检测所有v的邻接顶点
            if(!visited[w]){			//w为v的尚未访问的邻接顶点
                visited[w]=TRUE;
                d[w]=d[u]+1;
                EnQueue(Q,w);
            }
    }
}
```

##### 广度优先生成树

​	在广度遍历的过程中，可以得到一颗遍历树，成为广度优先生成树，遍历非连通图可得广度优先生成森林。

​	图的邻接矩阵存储是唯一的，广度优先生成树是唯一的；邻接表存储不是唯一的，广度优先生成树也不唯一。

#### 6.2.2深度优先搜索DFS

​	深度优先搜索类似于树的先序遍历，尽可能深地搜索一个图。

##### 算法思想

​	首先访问图中某一起始顶点v，然后由v出发，访问v邻接且未被访问的顶点w~1~，再访问与w~1~邻接且未被访问的任一顶点w~2~，重复上述过程。当不能继续向下访问时，一次退回最近被访问的顶点，若它还有邻接顶点未被访问过，则从该点开始继续上述搜索过程，直到图中所有点都被访问。

```c
bool visited[MAX_VERTEX_NUM];
void DFSTraverse(Graph G){
    for(v=0;v<G.vexnum;++v)
        visited[v]=FALSE;
    for(v=0;v<G.vexnum;++v)
        if(!visited[v])
            DFS(G,v);
}
void DFS(Graph G,int v){
    visit(V);
    visited[v]=TRUE;
    for(w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w))
        if(!visited[w])
            DFS(G,w);
}
```

​	空间复杂度：DFS是递归算法，需要借助递归工作栈，空间复杂度为O(|V|)
​	时间复杂度：邻接矩阵存储的时间复杂度为O(|V|^2^)；邻接表存储的时间复杂度为O(|V|+|E|)

##### 深度优先生成树

​	由深度优先遍历确定的树。深度优先遍历非连通图可得深度优先生成森林。

​	邻接表存储的图表示方式不唯一，深度优先遍历序列、生成树也不唯一。

#### 6.2.3图的连通性

​	图的遍历算法可用来判断图的连通性。

1. 无向图

​	若从任一结点出发，只需一次遍历就能访问图中所有结点，则无向图是连通的。

​	连通分量数=DFS/BFS调用次数。

2. 有向图

​	若从起始顶点到其他顶点都有路径，则只需调用1次DFS/BFS函数。

​	对于强连通图，从任一顶点出发都只需调用1次DFS/BFS函数

### 6.3图的应用

#### 6.3.1最小生成树

​	对于一个带权连通无向图G=(V,E)，生成树不同，每棵树的权（即树中所有边上的权值之和）也可能不同。
​	设R为G的所有生成树的集合，若T为R中边的权值之和最小的生成树，则T称为G的最小生成树（Minimum-Spanning-Tree，MST）。

​	性质：

- 最小生成树不唯一。当图中各边权值互不相等时，G的最小生成树是唯一的；若无向连通图G的边数比顶点数少1，即G本身是一颗树时，则G的最小生成树就是其本身。
- 最小生成树的边的权值是唯一的，而且是最小的。
- 最小生成树的边数是顶点数减一。

```c
GENERIC_MST(G){
    T=NULL;
    while T 未形成一颗生成树;
    	do 找到一条最小代价边(u,v)并且加入T后不会产生回路;
    		T=T∪(u,v);
}
```

##### Prim算法

​	Prim（普里姆）算法的执行非常类似于寻找图的最短路径的Dijkstra算法。

​	从某一个顶点开始构建生成树，每次将相邻代价最小的新顶点纳入生成树，直到所有顶点都纳入为止。

![image-20221118085952293](https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221118085952293.png)

```c
void Prim(G,T){
    T=空;				//初始化空树
    U={w};				//添加任一顶点w
    while((V-U)!=空){	//若树中不含全部顶点	
        设(u,v)是使u∈U与v∈(V-U)，且权值最小的边;
        T=T∪{(u,v)};	//边归入树
        U=U∪{v};		//顶点归入树
    }
}
```

​	时间复杂度：O(|V|^2^)；适合用于边稠密图。

##### Kruskal 算法

​	Kruskal （克鲁斯卡尔）算法是一种按权值的递增次序选择合适的边来构造最小生成树的方法。

​	每次选择一条权值最小的边，使这条边的两头连通（原本已经连通的就不选），直到所有结点都连通。

![image-20221118090241966](https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221118090241966.png)

```c
void Kruskal(V,T){
    T=V;							//初始化树T，仅含顶点
    numS=n;							//连通分量数
    while(numS>1){					//若连通分量大于1
        从E中取出权值最小的边(v,u);
        if(v和u属于T中不同的连通分量){
            T=T∪{(v,u)};			//将此边加入生成树
            numS--;					//连通分量减1
        }
    }
}
```

​	时间复杂度：通常采用堆来存放边的集合，选取最小权值边需要O(log|E|)，时间复杂度为O(|E|log|E|)；
​	适合用于边稀疏图。

#### 6.3.2最短路径算法

​	广度优先搜索最短路径只是对无权图而言的。当图是带权图时，把从一个顶点v~0~到图中其余任一顶点v~i~的一条路径所经过边上的权值之和，定义为该路径的带权路径长度，把带权路径长度最短的那条路径称为最短路径。

##### Dijkstra算法（求单源最短路径问题）

​	Dijkstra算法设置一个集合S记录已经求得的最短路径的顶点，初始把源点v~0~放入S，集合S每并入一个新顶点v~i~，都要修改源点v~0~到集合V-S中顶点当前的最短路径长度值。

![image-20221118091923844](https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221118091923844.png)

辅助数组：

- dist[]:记录从源点v~0~到其他各顶点当前的最短路径长度。
  初值：若从v~0~到v~i~有弧，则dist[i]为弧的权值，否则为∞。

  ![image-20221118091934682](https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221118091934682.png)

- path[]:path[i]表示从源点到顶点i之间最短路径的前驱结点。在算法结束后可根据其值追溯到源点v~0~到顶点v~i~的最短路径。

![image-20221118092243678](https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221118092243678.png)

算法步骤：

1. 选取起始点v~0~，填充最短路径长度和前驱数组
2. 选取最短路径长度的最小值，且未找到最短路径的结点，加入找到最短路径顶点集合S
3. 根据此结点再次填充最短路径长度与前驱结点数组
4. 重复第2、3步，直到所有结点都找到最短路径

![image-20221118093622518](https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221118093622518.png)

时间复杂度：O(|V|^2^)

缺点：边上带有负权值时，Dijkstra算法并不适用。

##### Floyd 算法（求各顶点之间最短路径问题）

算法思想：

​	动态规划，递推产生一个方阵序列A^(-1)^，A^(0)^，…，A^(k)^，…，A^(n-1)^，其中A^(k)^[i] [j]表示从顶点v~i~到v~j~的路径长度，k表示绕行第k个顶点的运算步骤。
​	初始时，对于任意两个顶点v~i~和v~j~，若它们之间存在边，则以此边上的权值作为它们之间的最短路径长度；若它们之间不存在有向边，则以∞作为它们之间的最短路径长度。
​	以后逐步尝试在原路径中加入顶点k（k=0，1，…，n-1）作为中间顶点。若增加中间顶点后，得到的路径比原来的路径长度减少了，则以此新路径代替原路径。

​													==**A^(k)^[i] [j]=Min{A^(k-1)^[i] [j],A^(k-1)^[i] [k]+A^(k-1)^[k] [j]}**==

![image-20221118094659056](https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221118094659056.png)<img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221118094702706.png" alt="image-20221118094702706" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221118101024633.png" alt="image-20221118101024633" style="zoom:50%;" />

![image-20221118101036924](https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221118101036924.png)

​	时间复杂度O(|V|^3^)；空间复杂度O(|V|^2^)

​	可以解决带负权图，不可解决带负权回路的图

#### 6.3.3有向无环图表达式（DAG）

​	若一个有向图中不存在环，则称为有向无环图，简称DAG图。

<img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221118102000783.png" alt="image-20221118102000783" style="zoom:50%;" /><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221118102353532.png" alt="image-20221118102353532" style="zoom:67%;" /><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221118102111822.png" alt="image-20221118102111822" style="zoom: 67%;" />

解题思路：

- Step 1：把各个操作数不重复地排成一排

- Step 2：标出各个运算符的生效顺序（先后顺序有点出入无所谓）
- Step 3：按顺序加入运算符，注意“分层”
- Step 4：从底向上逐层检查同层的运算符是否可以合体

#### 6.3.4拓扑序列

##### AOV网

​	用DAG图（有向无环图）表示一个工程。顶点表示活动，有向边<V~i~，V~j~>表示活动V~i~必须先于活动V~j~进行

##### 拓扑排序

1. 在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序：
		①每个顶点出现且只出现一次。
		②若顶点A在序列中排在顶点B的前面，则在图中不存在从顶点B到顶点A的路径。

2. 操作：
   	①从AOV网中选择一个没有前驱（入度为0）的顶点并输出。
   	②从网中删除该顶点和所有以它为起点的有向边。
   	③重复①和②直到当前的AOV网为空或当前网中不存在无前驱的顶点为止。

<img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221118102830334.png" alt="image-20221118102830334" style="zoom:50%;" />

3. 算法：
   	使用**记录当前顶点入度数组**和**拓扑序列数组**和保存**入度为0的栈**
   	寻找入度为0的点入栈，删除栈顶顶点，
   	将弹出顶点存储到拓扑序列数组，将与该顶点相连的点入度数组中数值减一

​		时间复杂度O(|V|+|E|)

​		拓扑排序、逆拓扑排序序列可能不唯一，原图存在回路则无拓扑排序；
​		邻接矩阵是三角矩阵，则存在拓扑序列，反之不成立。

##### 逆拓扑序列

对一个AOV网，如果采用下列步骤进行排序，则称之为**逆拓扑排序**：
	①从AOV网中选择一个没有后继（出度为0）的顶，点并输出。
	②从网中删除该顶，点和所有以它为终，点的有向边。
	③重复①和②直到当前的AOV网为空。

#### 6.3.5关键路径

##### AOE网

​	在带权有向图中，以顶点表示事件，以有向边表示活动，以边上的权值表示完成该活动的开销（如完成活动所需的时间），称之为用边表示活动的网络，简称AOE网（Activity On Edge NetWork）。

**性质：**
	①只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始；
	②只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生。
	另外，有些活动是可以并行进行的

1. 在AOE网中仅有一个入度为0的顶点，称为**开始顶点（源点）**，它表示整个工程的开始；也仅有一个出度为0的顶点，称为**结束顶点（汇点）**，它表示整个工程的结束。

2. 从源点到汇点的有向路径可能有多条，所有路径中，具有最大路径长度的路径称为**关键路径**，而把关键路径上的活动称为**关键活动**。

3. 完成整个工程的**最短时间**就是**关键路径的长度**，若关键活动不能按时完成，则整个工程的完成时间就会延长。

##### 关键路径

1.  概念

- 事件vk的最早发生时间ve(k)：决定了所有从v开始的活动能够开工的最早时间。
- 活动ai的最早开始时间e(i)：指该活动弧的起点所表示的事件的最早发生时间。
- 事件vk的最迟发生时间vl(k)：它是指在不推迟整个工程完成的前提下，该事件最迟必须发生的时间。
- 活动ai的最迟开始时间l(i)：它是指该活动弧的终点所表示事件的最迟发生时间与该活动所需时间之差。

2. 关键路径

​	活动ai的时间余量d(i)=l(i)-e(i)，表示在不增加完成整个工程所需总时间的情况下，活动a可以拖延的时间若一个活动的时间余量为零，则说明该活动必须要如期完成，d(i)=0即l(i)=e(i)的活动ai是**关键活动**，由关键活动组成的路径就是**关键路径**

3. 算法思想

![image-20221118104741525](https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221118104741525.png)

1. 求所有事件的**最早发生时间ve()**：按拓扑排序序列，依次求各个顶点的ve(k)
   ve(源点)=0；ve(k)=Max{ve(j)+Weight(v~j~,v~k~)}，v~j~为v~k~的任意前驱

2. 求所有事件的**最迟发生时间vl()**：按逆拓扑排序序列，依次求各个顶点的vl(k):

   vl(汇点)=ve(汇点)；vl(k)=Min{vl(j)-Weight(v~k~,v~j~)}，v~j~为v~k~的任意后继

3. 求所有活动的**最早发生时间e()**：若边<v~k~,v~j~>表示活动a~i~，则有e(i)=ve(k)

4. 求所有活动的**最迟发生时间l()**：若边<v~k~,v~j~>表示活动a~i~，则有l(i)=vl(i)-Weight(v~k~,v~j~)

5. 求所有活动的**时间余量d()**：d(i)=l(i)-e(i)

6. d(k)=0的活动就是关键活动，由关键活动可得关键路径

4. 特性

- 若关键活动耗时增加，则整个工程的工期将增长
- 缩短关键活动的时间，可以缩短整个工程的工期
- 当缩短到一定程度时，关键活动可能会变成非关键活动
- 可能有多条关键路径，只提高一条关键路径上的关键活动速度并不能缩短整个工程的工期，只有加快那些包括在所有关键路径上的关键活动才能达到缩短工期的目的。

## 七、查找

### 7.1顺序查找

​	顺序查找又称线性查找，它对顺序表和链表都是适用的。

​	对于顺序表，可通过数组下标递增来顺序扫描每个元素；对于链表，可通过指针next来依次扫描每个元素。

1. 一般线性表的顺序查找

​	引入“哨兵”，目的是使得循环不必判断数组是否越界，避免不必要的判断语句。

```c
typedef struct {		//查找表数据结构
	ElemType* elem;		//动态数组基址
	int TableLen;		//表的长度
}SSTable;
//不带“哨兵”的顺序查找
int Search_Seq(SSTable ST, ElemType key) {
	int i;
	for (i = 0; i < ST.TableLen && ST.elem[i].value != key.value; i++);
	//查找成功，返回元素下标；查找失败，返回-1
	return i == ST.TableLen ? -1 : i;
}
//带“哨兵”的顺序查找
int Search_SSeq(SSTable ST, ElemType key) {
	ST.elem[0] = key;			//哨兵
	int i;
	for (i = ST.TableLen; ST.elem[i].value != key.value; --i);
	return i;
} 
```

平均查找长度$ASL~成功~=\frac{n+1}{2}$；$ASL~不成功~=n+1$

2. 有序表顺序查找

​	若在查找之前就已经知道表是关键字有序的，则查找失败时可以不用再比较到表的另一端就能返回查找失败的信息，从而降低顺序查找失败的平均查找长度。

​	查找判定树![image-20221118111649740](https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221118111649740.png)
​	成功结点的关键字对比次数=结点所在层数 ；失败结点的关键字对比次数=其父节点所在层数

​	平均查找长度$ASL~不成功~=\frac{n}{2}+\frac{n}{n+1}$

时间复杂度：O(n)

### 7.2折半查找

​	折半查找又称二分查找，它仅适用于**有序的顺序表**。

1. **算法思想：**
   在[low，high]之间找目标关键字，每次检查mid=（low+high）/2
   根据mid所指元素与目标关键字的大小调整low或high，不断缩小low和high的范围
   若low>high则查找失败

```c
//折半查找
int Binary_Search(SSTable L, ElemType key) {
	int low = 0, high = L.TableLen - 1, mid;
	while (low <= high) {
		mid = (low + high) / 2;
		if (L.elem[mid].value == key.value)
			return mid;
		else if (L.elem[mid].value > key.value)
			high = mid - 1;
		else
			low = mid + 1;
	}
	return -1;
}
```

2. **判定树：**
   由mid所指元素将原有元素分割到左右子树中，是一颗**平衡二叉树**。

<img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221118141153981.png" alt="image-20221118141153981" style="zoom:50%;" />

特性：

- 折半查找的判定树是平衡的二叉排序树（左<中<右）
- 折半查找判定树，只有最下面一层是不满的
- 若查找表有n个关键字，则失败结点有n+1个
- 树高h=$\lceil log_2(n + 1)\rceil$（不包含失败结点）
- 查找树取中间结点要么偏左，要么偏右，树形要么左子树结点数大于等于右子树，要么相反。

平均查找长度：ASL~成功~=log~2~(n+1)-1（树高-1）；
						  上图中ASL~成功~=(1×1+2×2+3×4+4×4)/11=3；ASL~失败~=(3×4+4×4)/11=11/3

时间复杂度：O(log~2~n)

### 7.3分块查找

​	分块查找又称*索引顺序查找*，数据分块存储，块内无序、块间有序，既有动态结构，又适于快速查找。

**算法思想：**

​	将查找表分为若干子块；块内元素可以无序，块间有序。
​	索引表中记录每个分块的**最大关键字**和**各块中第一个元素的地址**，索引表按关键字有序排序
​	查找过程：先查索引表（顺序或折半）、再对分块内进行顺序查找。

![image-20221118143151619](https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221118143151619.png)

**平均查找长度**：ASL=L~I~+L~S~（索引查找和块内查找的平均长度之和）
				将长度为n的查找表均匀分为b块，每块有s个记录
						  顺序查找索引表：$ASL=\frac{b+1}{2}+\frac{s+1}{2}$；当$s=\sqrt{n}$时，$ASL_{min}=\sqrt{n}+1$
						  折半查找索引表：$ASL= \lceil log_2(b+1) \rceil+\frac{s+1}{2}$

注意：对索引表进行折半查找时，若索引表中不包含目标关键字，则折半查找最终停在low>high，要在**low所指分块**中查找

### 7.4树形查找

#### 7.4.1二叉排序树BST

1. 定义

​	二叉排序树（也称二叉查找树）或者是一棵空树，或者是具有下列特性的二叉树：

- 若左子树非空，则左子树上所有结点的值均小于根结点的值。
- 若右子树非空，则右子树上所有结点的值均大于根结点的值。
- 左、右子树也分别是一棵二叉排序树。

​	左子树结点值<根结点值<右子树结点值；所以对二叉排序树进行中序遍历，可以得到一个递增的有序序列。

```c
//二叉排序树结点
typedef struct BSTNode {
	int key;
	struct BSTNode* lchild, * rchild;
}BSTNode, * BSTree;
```

2. 查找

​	算法思想：若二叉排序树非空，先将给定值与根结点的关键字比较，若相等，则查找成功：若不等，如果小于根结点的关键字，则在根结点的左子树上查找，否则在根结点的右子树上查找。

```c
//在二叉排序树中查找值为key的结点
BSTNode* BST_Search(BSTree T, ElemType key) {
	while (T != NULL && key != T->key) {
		if (key < T->key)T = T->lchild;
		else T = T->rchild;
	}
	return T;
}
```

3. 插入

​	二叉排序树作为一种动态树表，其特点是树的结构通常不是一次生成的，而是在查找过程中，当树中不存在关键字值等于给定值的结点时再进行插入的。

​	插入结点的过程如下：若原二叉排序树为空，则直接插入结点；否则，若关键字k小于根结点值，则插入到左子树，若关键字k大于根结点值，则插入到右子树。插入的结点一定是一个新添加的叶结点，且是查找失败时的查找路径上访问的最后一个结点的左孩子或右孩子。

```c
//在二叉排序树插入关键字为k的新结点（递归实现）
int BST_Insert(BSTree& T, KeyType k) {
	if (T == NULL) {
		T = (BSTree)malloc(sizeof(BSTNode));
		T->key = k;
		T->lchild = T->rchild = NULL;
		return 1;
	}
	else if (k == T->key)
		return 0;
	else if (k < T->key)
		return BST_Insert(T->lchild, k);
	else
		return BST_Insert(T->rchild, k);
}
```

4. 构造

​	从一棵空树出发，依次输入元素，将它们插入二叉排序树中的合适位置。

```c
//按照str[]中的关键字序列建立二叉排序树
void Create_BST(BSTree& T, KeyType str[], int n) {
	T = NULL;
	int i = 0;
	while (i<n){
		BST_Insert(T, str[i]);
		i++;
	}
}
```

5. 删除

**算法思想：**

先搜索找到目标结点：

- ①若被删除结点z是叶结点，则直接删除，不会破坏二叉排序树的性质。
- ②若结点z只有一棵左子树或右子树，则让z的子树成为z父结点的子树，替代z的位置。
- ③若结点z有左、右两棵子树，则令z的直接后继（或直接前驱）替代z，然后从二叉排序树中删去这个直接后继（或直接前驱），这样就转换成了第一或第二种情况。

<img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221118150451495.png" alt="image-20221118150451495" style="zoom:67%;" />

6. 查找效率分析

​	二叉排序树的查找效率，主要取决于树的高度。若二叉排序树的左、右子树的高度之差的绝对值不超过1，则这样的二叉排序树称为平衡二叉树，它的平均查找长度为O(Iog~2~n)。
​	若二叉排序树是一个只有右（左）孩子的单支树（类似于有序的单链表），则其平均查找长度为O(n)。

平均查找成功长度与平均查找失败长度：

<img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221118150920368.png" alt="image-20221118150920368" style="zoom:50%;" /><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221118150929035.png" alt="image-20221118150929035" style="zoom:50%;" />

#### 7.4.2平衡二叉树

1. 定义

​	平衡二叉树（Balanced Binary Tree），树上任一结点的左子树和右子树的高度之差不超过1。

​	结点的平衡因子=左子树高-右子树高；平衡二叉树的平衡因子值只可能是0，1，-1

2. 平衡二叉树的插入

​	每次调整的对象都是“最小不平衡子树”，即以插入路径上离插入结点最近的平衡因子的绝对值大于1的结点作为根的子树。

- **LL平衡旋转**（右单旋转）

​		由于在A的左孩子的左子树中插入新结点，导致不平衡，需要对**A的左孩子结点右上旋**。
​		将A的左孩子B向右上旋转代替A成为根结点，将A结点向右下旋转成为B的右子树的根结点，而B的原右子树则作为A结点的左子树。

![image-20221118151914870](https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221118151914870.png)

- **RR平衡旋转**（左单旋转）

​		由于在A的右孩子的右子树中插入新结点，导致不平衡，需要对**A的右孩子结点左上旋**。
​		将A的右孩子B向左上旋转代替A成为根结点，将A结点向左下旋转成为B的左子树的根结点，而B的原左子树则作为A结点的右子树。

![image-20221118152226560](https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221118152226560.png)

- **LR平衡旋转**（先左后右双旋转）

​		由于在A的左孩子的右子树中插入新结点，导致不平衡，需要对**A的左孩子的右孩子先左上旋再右上旋**。
​		先将A结点的左孩子B的右子树的根结点C向左上旋转提升到B结点的位置，然后把该C结点向右上旋转提升到A结点的位置。

![image-20221118152412730](https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221118152412730.png)

- **RL平衡旋转**（先右后左双旋转）

​		由于在A的右孩子的左子树中插入新结点，导致不平衡，需要对**A的右孩子的左孩子先右上旋后左上旋**。
​		先将A结点的右孩子B的左子树的根结点C向右上旋转提升到B结点的位置，然后把该C结点向左上旋转提升到A结点的位置。

![image-20221118152732314](https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221118152732314.png)

3. 平衡二叉树的删除

算法思想：

- 1）用二叉排序树的方法对结点w执行删除操作。

- 2）从结点w开始，向上回溯，找到第一个不平衡的结点z（即最小不平衡子树）：y为结点z的高度最高的孩子结点；x是结点y的高度最高的孩子结点。

- 3）然后对以z为根的子树进行平衡调整，其中x、y和z可能的位置有4种情况：

  ​	y是z的左孩子，x是y的左孩子（LL，右单旋转）；
  ​	y是z的左孩子，x是y的右孩子（LR，先左后右双旋转）；
  ​	y是z的右孩子，x是y的右孩子（RR，左单旋转）；
  ​	y是z的右孩子，x是y的左孩子（RL，先右后左双旋转）。

  ​	这四种情况与插入操作的调整方式一样。不同之处在于，插入操作仅需要对以z为根的子树进行平衡调整：而删除操作就不一样，先对以z为根的子树进行平衡调整，如果调整后子树的高度减1，则可能需要对z的祖先结点进行平衡调整，甚至回溯到根结点（导致树高减1）。

  ![image-20221118153045130](https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221118153045130.png)

4. 查找

​	在平衡二叉树上进行查找的过程与二叉排序树的相同。

​	若树高为h，则最坏情况下，查找一个关键字最多需要对比h次，即查找操作的时间复杂度不可能超过O(h)
​	含有n个结点的平衡二叉树的最大深度为O(log~2~n)，因此平衡二叉树的平均查找长度为O(log~2~n)。

#### 7.4.3红黑树

1. 定义

​	为了保持AVL树的平衡性，插入和删除操作后，非常频繁地调整全树整体拓扑结构，代价较大。为此在AVL树的平衡标准上进一步放宽条件，引入了红黑树的结构。

​	一棵红黑树是满足如下红黑性质的二叉排序树：

- ①每个结点或是红色，或是黑色的。
- ②根结点是黑色的。
- ③叶结点（虚构的外部结点、NULL结点）都是黑色的。
- ④不存在两个相邻的红结点（即红结点的父结点和孩子结点均是黑色的）。
- ⑤对每个结点，从该结点到任一叶结点的简单路径上，所含黑结点的数量相同。

![image-20221118153806439](https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221118153806439.png)

​	从某结点出发（不含该结点）到达一个叶结点的任一简单路径上的黑结点总数称为该结点的**黑高**（记为bh），黑高的概念是由性质⑤确定的。根结点的黑高称为红黑树的黑高。

**结论1**：从根到叶结点的最长路径不大于最短路径的2倍。

**结论2**：有n个内部结点的红黑树的高度h≤2log~2~(n+1)。

​	可见，红黑树的“**适度平衡**”，由AVL树的“高度平衡”，降低到“任一结点左右子树的高度，相差不超过2倍”，也降低了动态操作时调整的频率。对于一棵动态查找树，如果插入和删除操作比较少，查找操作比较多，采用AVL树比较合适，否则采用红黑树更合适。但由于维护这种高度平衡所付出的代价比获得的效益大得多，红黑树的实际应用更广泛，C+中的map和set（Java中的TreeMap和TreeSet）就是用红黑树实现的。

2. 红黑树的效率

​	红黑树的查找，插入和删除操作，**时间复杂度**都是O(log~2~n)。

3. 红黑树的插入

**结论3**：新插入红黑树中的结点初始着为红色。

插入算法：

- 1）用二叉查找树插入法插入，并将结点z着为红色。若结点z的父结点是黑色的，无须做任何调整，此时就是一棵标准的红黑树。

- 2）如果结点z是根结点，将z着为黑色（树的黑高增1），结束。

- 3）如果结点z不是根结点，并且z的父结点z.p是红色的，则分为下面三种情况，区别在于z的叔结点y的颜色不同，因z.P是红色的，插入前的树是合法的，根据性质②和④，爷结点z.p.p必然存在且为黑色。性质④只在z和zp之间被破坏了。

  *情况1：z的叔结点y是黑色的，且z是一个右孩子。*

  ​	情况1（LR，先左旋，再右旋），即z是爷结点的左孩子的右孩子。先做一次左旋将此情形转变为情况2（变为情况2后再做一次右旋），左旋后z和父结点z.p交换位置。因为z和z.p都是红色的，所以左旋操作对结点的黑高和性质⑤都无影响。

  *情况2：z的叔结点y是黑色的，且z是一个左孩子。*

  ​	情况2（LL，右单旋），即z是爷结点的左孩子的左孩子。做一次右旋，并交换z的原父结点和原爷结点的颜色，就可以保持性质⑤，也不会改变树的黑高。这样，红黑树中也不再有连续两个红结点，结束。

  ![image-20221118155413882](https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221118155413882.png)

  *情况3：如果x的叔结点y是红色。*

  ​	情况3（z是左孩子或右孩子无影响），z的父结点z.p和叔结点y都是红色的，因为爷结点z.p.p是黑色的，将z.p和y都着为黑色，将z.p.p着为红色，以在局部保持性质④和⑤。然后，把z.p.p作为新结点z来重复循环，指针z在树中上移两层。

  ![image-20221118155437839](https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221118155437839.png)

4. 红黑树的删除

​	删除过程也是先执行二叉查找树的删除方法。若待删结点有两个孩子，不能直接删除，而要找到该结点的中序后继（或前驱）填补，即右子树中最小的结点，然后转换为删除该后继结点。
​	由于后继结点至多只有一个孩子，这样就转换为待删结点是叶结点或仅有一个孩子的情况。

- 待删结点没有孩子。

  1）如果待删结点没有孩子，若该结点是红色的，直接删除，无须做任何调整。
  2）如果待删结点没有孩子，并且该结点是黑色的。假设待删结点为y，x是用来替换y的结点（注意，当y是终端结点时，X是黑色的NULL结点）。有以下四种情况，区别在于x的兄弟结点w及w的孩子结点的颜色不同：

  *情况1：x的兄弟结点w是红色的。*

  ![image-20221118160221339](https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221118160221339.png)

  *情况2：x的兄弟结点w是黑色的，w的左孩子是红色的，w的右孩子是黑色的。*（RL，先右旋，再左旋）

  ![image-20221118160318724](https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221118160318724.png)

  *情况3：x的兄弟结点w是黑色的，且w的右孩子是红色的。*（RR，左单旋）

  ![image-20221118160410255](https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221118160410255.png)

  *情况4：x的兄弟结点w是黑色的，且w的两个孩子结点都是黑色的。*

  ![image-20221118160518723](https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221118160518723.png)

- 待删结点只有右子树或左子树。

  ![image-20221118155929941](https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221118155929941.png)只有这两种情况存在。子树只有一个结点，且必然是红色，否则会破坏性质⑤。

### 7.5B树和B+树

#### 7.5.1B树

1. 定义

​	B树，又称多路平衡查找树，B树中所有**结点的孩子个数的最大值**称为**B树的阶**，通常用m表示。一棵m阶B树或为空树，或为满足如下特性的m叉树：

1）树中每个结点至多有m棵子树，即至多含有m-1个关键字。
2）若根结点不是终端结点，则至少有两棵子树。
3）除根结点外的所有非叶结点至少有$\lceil m/2 \rceil$棵子树，即至少含有$\lceil m/2 \rceil-1$个关键字。
4）所有非叶结点的结构如下：

<img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221118160924089.png" alt="image-20221118160924089" style="zoom:67%;" />

其中，K~i~(i=1，2，…，n)为结点的关键字，且满足K~1~<K~2~<……<K~n~；P~i~(i=0，1，…，n)为指向子树根结点的指针，且指针P~i-1~所指子树中所有结点的关键字均小于K~i~，P~i~所指子树中所有结点的关键字均大于K~i~，n($\lceil m/2 \rceil-1$≤n≤m-1)为结点中关键字的个数。

5）所有的叶结点都出现在同一层次上，并且不带信息（可以视为外部结点或类似于折半查找判定树的查找失败结点，实际上这些结点不存在，指向这些结点的指针为空）

​	下图为一棵5阶B树。

![image-20221118161433116](https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221118161433116.png)

2. 性质

- 根节点的子树数∈[2，m]，关键字数∈[1，m-1]。
  其他结点的子树数∈[$\lceil m/2 \rceil$，m]；关键字数∈[$\lceil m/2 \rceil-1$，m-1]
- 对任一结点，其所有子树高度都相同
- 关键字的值：子树0<关键字1<子树1<关键字2<子树2<....（类比二叉查找树左<中<右）

3. 最大高度和最小高度

​	最小高度：让每个结点尽可能的满，有m-1个关键字，m个分叉，则有n≤m^h^-1；因此h≥log~m~(n+1)

​	最大高度：让各层的分叉尽可能的少，即根节点只有2个分叉，其他结点只有$\lceil m/2 \rceil$个分叉，则第h+1层共有叶子结点（失败结点）$2(\lceil m/2 \rceil)^{h-1}$个，n个关键字的B树必有n+1个叶子结点，则n+1≥$2(\lceil m/2 \rceil)^{h-1}$，即h≤$log_{\lceil m/2 \rceil}\frac{n+1}{2}+1$

​	含n个关键字的m叉B树：$log_m(n+1)≤h≤log_{\lceil m/2 \rceil}\frac{n+1}{2}+1$

3. 查找

​	在B树上进行查找与二叉查找树很相似，只是每个结点都是多个关键字的有序表，在每个结点上所做的不是两路分支决定，而是根据该结点的子树所做的多路分支决定。

​	B树的查找包含两个基本操作：①在B树中找结点：②在结点内找关键字。由于B树常存储在磁盘上，因此前一个查找操作是在磁盘上进行的，而后一个查找操作是在内存中进行的，即在找到目标结点后，先将结点信息读入内存，然后在结点内采用顺序查找法或折半查找法。

​	在B树上查找到某个结点后，先在有序表中进行查找，若找到则查找成功，否则按照对应的指针信息到所指的子树中去查找；查找到叶结点时（对应指针为空指针），则说明树中没有对应的关键字，查找失败。

4. 插入

​	通过“查找”确定插入位置（一定是在终端结点）

​	若插入后结点关键字个数未超过上限，则无需做其他处理

​	若插入后关键字个数超过上限，则需要将当前结点的中间元素放到父节点中，当前结点分裂为两个部分；该操作会导致父节点关键字个数+1，若父节点关键字个数也超过了上限，则需要再向上分裂；根节点的分裂会导致B树高度+1。

![image-20221118163208905](https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221118163208905.png)

5. 删除

​	B树中的删除操作与插入操作类似，但要稍微复杂一些，即要使得删除后的结点中的关键字个数≥$\lceil m/2 \rceil-1$，因此将涉及结点的“合并”问题。

- 非终端结点关键字：

  用其直接前驱或直接后继替代其位置，转化为对“终端结点”的删除

  直接前驱：当前关键字左边指针所指子树中“最右下”的元素

  直接后继：当前关键字右边指针所指子树中“最左下”的元素

- 终端结点关键字：

  删除后结点关键字个数未低于下限，无需任何处理

  低于下限时，
  ①右兄弟够借，则用当前结点的后继、后继的后继依次顶替空缺；
  ②左兄弟够借，则用当前结点的前驱、前驱的前驱依次顶替空缺；
  ③左（右）兄弟都不够借，则需要与父结点内的关键字、左（右）兄弟进行合并。合并后导致父节点关键字数量-1，可能需要继续合并。

  <img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221118180540259.png" alt="image-20221118180540259" style="zoom:80%;" />

#### 7.5.2B+树

1. 定义

一棵m阶的B+树需满足下列条件：

- 每个分支结点最多有m棵子树（孩子结点）
- 非叶根结点至少有两棵子树，其他每个分支结点至少有$\lceil m/2 \rceil$棵子树
- 结点的子树个数与关键字个数相等
- 所有叶结点包含全部关键字及指向相应记录的指针，叶结点中将关键字按大小顺序排列，并且相邻叶结点按大小顺序相互链接起来
- 所有分支结点中仅包含它的各个子结点中关键字的最大值及指向其子结点的指针。

![image-20221118182217814](https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221118182217814.png)

2. 查找

​	B+树中，无论查找成功与否，最终一定都要走到最下面一层结点。

​	分支结点的某个关键字是其子树中最大关键字的副本。通常在B+树中有两个头指针：一个指向根结点，另一个指向关键字最小的叶结点。因此，可以对B+树进行两种查找运算：一种是从最小关键字开始的顺序查找，另一种是从根结点开始的多路查找。

3. B+树与B树的区别

- 在B+树中，具有n个关键字的结点只含有n棵子树，即每个关键字对应一棵子树：而在B树中，具有n个关键字的结点含有n+1棵子树。
- B+树中，非根内部结点的关键字个数范围是$\lceil m/2 \rceil≤n≤m$；
  B树中，非根内部结点的关键字个数范围是$\lceil m/2 \rceil-1≤n≤m-1$。
- 在B+树中，叶结点包含信息，所有非叶结点仅起索引作用，非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。
- 在B+树中，叶结点包含了全部关键字，即在非叶结点中出现的关键字也会出现在叶结点中；
  而在B树中，叶结点（最外层内部结点）包含的关键字和其他结点包含的关键字是不重复的。

<img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221118183423398.png" alt="image-20221118183423398" style="zoom: 80%;" />

### 7.6散列查找

#### 7.6.1散列表

1. 散列函数：一个把查找表中的关键字映射成该关键字对应的地址的函数，记为Hash（key）=Addr（这里的地址可以是数组下标、索引或内存地址等）。
2. 冲突：散列函数可能会把两个或两个以上的不同关键字映射到同一地址，称这种情况为*冲突*，这些发生碰撞的不同关键字称为*同义词*。一方面，设计得好的散列函数应尽量减少这样的冲突：另一方面，由于这样的冲突总是不可避免的，所以还要设计好处理冲突的方法。
3. 散列表：根据关键字而直接进行访问的数据结构。也就是说，散列表建立了关键字和存储地址之间的一种真接映射关系。
4. 装填因子：装填因子a=表中记录个数/散列表表长

​	理想情况下，对散列表进行查找的时间复杂度为O（1），即与表中元素的个数无关。下面分别介绍常用的散列函数和处理冲突的方法。

#### 7.6.2散列函数构造

设计目标：让不同关键字的冲突尽可能地少。

1. 直接定址法	散列函数：$H(key)=key$或$H(key)=a× key +b$

​	直接取关键字的某个线性函数值为散列地址。其中，a和b是常数。这种方法计算最简单，且不会产生冲突。它适合关键字的分布基本连续的情况，若关键字分布不连续，空位较多，则会造成存储空间的浪费。

2. 除留余数法	散列函数：H(key)=key %p

​	这是一种最简单、最常用的方法，假定散列表表长为m，取一个不大于m但最接近或等于m的质数P。

3. 数字分析法	选取数码分布较为均匀的若干位作为散列地址

​	设关键字是r进制数（如十进制数），而r个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀一些，每种数码出现的机会均等；而在某些位上分布不均匀，只有某几种数码经常出现，此时可选取数码分布较为均匀的若干位作为散列地址。这种方法适合于已知的关键字集合，若更换了关键字，则需要重新构造新的散列函数。

4. 平方取中法	取关键字的平方值的中间几位作为散列地址

​	具体取多少位要视实际情况而定。这种方法得到的散列地址与关键字的每位都有关系，因此使得散列地址分布比较均匀，适用于关键字的每位取值都不够均匀或均小于散列地址所需的位数。

​	散列查找是典型的“用空间换时间”的算法，只要散列函数设计的合理，则散列表越长，冲突的概率越低。

#### 7.6.3处理冲突

1. 拉链法

​		同义词串成一个链表。为了避免非同义词发生冲突，可以把所有的同义词存储在一个线性链表中，这个线性链表由其散列地址唯一标识。假设散列地址为的同义词链表的头指针存放在散列表的第个单元中，因而查找、插入和删除操作主要在同义词链中进行。拉链法适用于经常进行插入和删除的情况。

<img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221118185814578.png" alt="image-20221118185814578"  />

2. 开放定址法

​	所谓开放定址法，是指可存放新表项的空闲地址既向它的同义词表项开放，又向它的非同义词表项开放。
​	其数学递推公式为H~i~=(H(key)+d~i~)%m，m表示散列表表长，d~i~为增量序列

- 线性探测法。当d~i~=0，1，2，…，m-1时，称为线性探测法；即发生冲突时，每次往后探测相邻的下一个单元是否为空。容易造成大量元素在相邻的散列地址上“聚集”（或堆积）起来，大大降低了查找效率。
- 平方探测法。当d~i~=0^2^，1^2^，-1^2^，2^2^，-2^2^，…，k^2^，-k^2^时，称为平方探测法，其中k≤m/2，散列表长度m必须是一个可以表示成4k+3的素数，又称二次探测法。
- 双散列法。当d~i~=Hash~2~（key）时，称为双散列法。需要使用两个散列函数，当通过第一个散列函数H(key）得到的地址发生冲突时，则利用第二个散列函数Hash~2~（key）计算该关键字的地址增量。它的具体散列函数形式如下：**H~i~=(H(key)+i×Hash~2~(key))%m**
  初始探测位置H~0~=H(key)%m。i是冲突的次数，初始为0。在再散列法中，最多经过m-1次探测就会遍历表中所有位置，回到H~0~位置。
- 伪随机序列法。当d=伪随机数序列时，称为伪随机序列法。

#### 7.6.4散列表查找及性能分析

1. 查找过程：

​	散列表的查找过程与构造散列表的过程基本一致。对于一个给定的关键字key，根据散列函数可以计算出其散列地址，执行步骤如下：

- 初始化：Addr=Hash（key）；
- ①检测查找表中地址为Addr的位置上是否有记录，若无记录，返回查找失败；若有记录，比较它与key的值，若相等，则返回查找成功标志，否则执行步骤②。
- ②用给定的处理冲突方法计算“下一个散列地址”，并把Addr置为此地址，转入步骤①。

2. 查找效率：取决于散列函数、处理冲突的方法、装填因子α

   散列表的平均查找长度依赖于散列表的装填因子α，α越大，表示装填的记录越“满”，发生冲突的可能性越大，反之发生冲突的可能性越小。

## 八、排序

### 8.1插入排序

算法思想:：每次将一个待排序的记录按其关键字大小插入到前面已排好序的子序列中，直到全部记录插入完成。

#### 8.1.1直接插入排序

​	顺序查找找到插入的位置，适用于顺序表、链表。

1. 算法思想：

- 1）查找出L(i)在L[1…i-1]中的插入位置k。
- 2）将L[k…i-1]中的所有元素依次后移一个位置。
- 3）将L(1)复制到L(k)。

```c
//直接插入排序
void InsertSort(ElemType A[], int n) {
	int i, j, temp;
	for (i = 1; i < n; i++) {
		temp = A[i];					//保存待排序元素
		for (j = i - 1; j >= 0 && A[j] > temp; --j)//从后往前查找待插入位置
			A[j + 1] = A[j];			//向后挪位
		A[j + 1] = temp;				//复制到插入位置
	}
}
//带哨兵的直接插入排序
void InsertSort(ElemType A[],int n){
    int i,j;
    for(i=2;i<=n;i++){					//一次将A[2]~A[n]插入前面一排序序列
        A[0]=A[i];						//复制为哨兵，A[0]不存放元素
        for(j=i-1;A[0]<A[j];--j)		//从后往前查找待插入位置
            A[j+1]=A[j];				//向后挪位
        A[j+1]=A[0];					//复制到插入位置
    }
}
```

2. 性能分析：

​	空间复杂度：O(1)；时间复杂度O(n^2^)。最好O(n)，待排序列为正序，每次排序只需比较一次不移动。

​	稳定性：稳定；适用性：适用于顺序存储和链式存储的线性表

#### 8.1.2折半插入排序

​	折半查找找到应插入的位置，仅适用于顺序表

1. 算法思想：
   	由于是顺序存储的线性表，所以查找有序子表时可以用折半查找来实现。确定待插入位置后，就可统一地向后移动元素。

​	注意：一直到**low>high**时才停止折半查找。当mid所指元素等于当前元素时，应继续令low=mid+1，以保证“稳定性”。**最终应将当前元素插入到low所指位置（即high+1）**

```c
//折半插入排序
void InsertSort(ElemType A[], int n) {
	int i, j, low, high, mid;
	for (i = 2; i <= n; i++) {				//依次将A[2]~A[n]插入前面已排序序列
		A[0] = A[i];						//将A[i]暂存到A[0]
		low = 1; high = i - 1;				//设置折半查找范围
		while (low <= high) {				//折半查找
			mid = (low + high) / 2;			//取中间点
			if (A[mid] > A[0])
				high = mid - 1;				//查找左半子表
			else low = mid + 1;				//查找右半子表
		}
		for (j = i - 1; j >= high + 1; --j)
			A[j + 1] = A[j];				//统一后移，空出插入位置
		A[high + 1] = A[0];					//插入操作
	}
}
```

2. 性能分析：

​	空间复杂度：O(1)；时间复杂度O(n^2^)。折半插入排序减少了元素的比较次数，约为O(nlog~2~n)。

​	稳定性：稳定。

#### 8.1.3希尔排序

1. 算法思想：
   	先将待排序表分割成若干形如$L[i，i+ d，i+ 2d，...，i+ kd]$的“特殊”子表，对各个子表分别进行直接插入排序。缩小增量d，重复上述过程，直到d=1为止。

2. 排序过程：
   	先取一个小于n的步长d~1~，把表中的全部记录分成d~1~组，所有距离为d~1~的倍数的记录放在同一组，在各组内进行直接插入排序：然后取第二个步长d~2~<d~1~，重复上述过程，直到所取到的d~k~=1，即所有记录已放在同一组中，再进行直接插入排序，由于此时已经具有较好的局部有序性，故可以很快得到最终结果。

<img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221119092652078.png" alt="image-20221119092652078" style="zoom:67%;" />

```c
//希尔排序
void ShellSort(int A[], int n) {
	int d, i, j;
	//A[0]只是暂存单元，不是哨兵，当j<=0时，插入位置已到
	for(d=n/2;d>=1;d=d/2)							//步长变化，每次变为上次的一半
		for(i=d+1;i<=n;i++)
			if (A[i] < A[i - d]) {					//将A[i]插入有序增量表
				A[0] = A[i];						//暂存在A[0]
				for (j = i-d;j>0 && A[0]<A[j];j-=d)
					A[j + d] = A[j];				//记录后移，查找到插入的位置
				A[j + d] = A[0];					//插入
			}
}
```

3. 性能分析

​	空间复杂度：O(1)；时间复杂度O(n^2^)。希尔排序时间复杂度依赖增量序列的函数，当n在特定范围可达O(n^1.3^)

​	稳定性：不稳定。当相同关键字记录划分到不同子表时，可能会改变它们之间的相对次序。

​	适用性：仅适用于顺序存储的线性表。

不能保证每一趟都有一个元素放到最终位置上。

### 8.2交换排序

​	所谓交换，是指根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置。

```c
//交换
void swap(int& a, int& b) {
	int temp = a;
	a = b;
	b = temp;
}
```

#### 8.2.1冒泡排序

1. 算法思想：
   	从后往前（或从前往后）两两比较相邻元素的值，若为逆序，则交换它们，直到序列比较完。称这样过程为“一趟”冒泡排序。最多只需n-1趟。	

   ​	排序每一趟排序都可以使一个元素的移动到最终位置，已确定最终位置的元素在之后的处理中无需再对比。

<img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221119094212802.png" alt="image-20221119094212802" style="zoom:50%;" />

```c
//冒泡排序
void BubbleSort(int A[], int n) {
	for (int i = 0; i < n ; i++) {
		bool flag = false;				//表示本趟冒泡是否发生交换的标志
		for(int j=n-1;j>i;j--)			//一趟冒泡过程
			if (A[j - 1] > A[j]) {		//若为逆序
				swap(A[j - 1], A[j]);	//交换
				flag = true;
			}
		if (flag == false)
			return;						//本趟遍历后没有发生交换，说明表已有序
	}
}
```

2. 性能分析

​	空间复杂度：O(1)；时间复杂度O(n^2^)。其中当初始序列有序时，时间复杂度为O(n)；

​	稳定性：稳定。适用性：顺序表、链表都可以。

#### 8.2.2快速排序

1. 算法思想

​	在待排序表L[1...n]中任取一个元素pivot作为**枢轴**（或基准，通常取首元素），通过一趟排序将待排序表划分为独立的两部分L[1...k-1]和L[k+1...n]，使得L[1...k-1]中的所有元素小于pivot，L[k+1...n]中的所有元素大于等于pivot，则pivot放在了其最终位置L(k)上，这个过程称为一次“划分”。然后分别递归地对两个子表重复上述过程，直至每部分内只有一个元素或空为止，即所有元素放在了其最终位置上。

​	算法表现主要取决于**递归深度**，若每次“划分”越均匀，则递归深度越低。“划分”越不均匀，递归深度越深。

​	一次划分可以确定一个元素的最终位置，而一趟排序也许可以确定**多个元素的最终位置**。

<img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221119094610141.png" alt="image-20221119094610141" style="zoom:67%;" />

```c
//用第一个元素将待排序序列划分成左右两个部分
int Partition(ElemType A[], int low, int high) {
	ElemType pivot = A[low];							//将表中第一个元素设为枢轴
	while (low < high) {								//循环跳出条件
		while (low < high && A[high] >= pivot)--high;
		A[low] = A[high];								//将比枢轴小的元素移动到左端
		while (low < high && A[low] <= pivot)++low;
		A[high] = A[low];								//将比枢轴大的元素移动到右端
	}
	A[low] = pivot;										//将枢轴放到最终位置
	return low;											//返回枢轴最终位置
}

//快速排序
void QuickSort(ElemType A[], int low, int high) {
	if (low < high) {									//递归跳出条件
		int pivotpos = Partition(A, low, high);			//划分
		QuickSort(A, low, pivotpos - 1);				//依次对两个子表进行递归划分
		QuickSort(A, pivotpos + 1, high);
	}
}
```

2. 性能分析

​	空间复杂度：需要借助递归工作栈保存信息，最好O(log~2~n)；最坏，进行n-1次递归，O(n)；平均O(log~2~n)。

​	时间复杂度：快排运行时间与划分是否对称有关，即初始表基本有序或逆序，最坏情况时间复杂度O(n^2^)。
​						   最理想情况下，时间复杂度O(nlog~2~n)。
​	==快速排序是所有内部排序算法中平均性能最优的排序算法。==

​	稳定性：不稳定。

注意：在快速排序算法中，并不产生有序子序列，但每趟排序后会将枢轴（基准）元素放到其最终的位置上。

### 8.3选择排序

​	基本思想：每一趟（如第i趟）在后面$n-i+1（i=1，2，…，n-1）$个待排序元素中选取关键字最小的元素，作为有序子序列的第i个元素，直到第n-1趟做完，待排序元素只剩下1个，就不用再选了。

#### 8.3.1简单选择排序

1. 算法思想

​	假设排序表为$L[1…n]$，第$i$趟排序即从$L[1…n]]$中选择关键字最小的元素与$L(i)$交换，每一趟排序可以确定一个元素的最终位置，这样经过$n-1$趟排序就可使得整个排序表有序。

```c
//简单选择排序
void SelectSort(int A[], int n) {
	for (int i = 0; i < n - 1; i++) {
		int min = i;
		for (int j = i + 1; j < n; j++)
			if (A[j] < A[min])min = j;
		if (min != i)swap(A[i], A[min]);
	}
}
```

2. 性能分析

​	空间复杂度：O(1)；时间复杂度O(n^2^)。

​	稳定性：不稳定。在第i趟找到最小元素后，和第i个元素交换，可能导致第i个元素与其含有相同关键字元素的相对位置改变。

​	适用性：顺序表、链表都可以。

#### 8.3.2堆排序

1. 堆的定义

​	顺序存储的“完全二叉树”，结点i的左孩子是2i；右孩子是2i+1；父节点是i/2；编号≤n/2的结点都是分支结点。

​	大根堆：根≥左、右；小根堆：根≤左、右

2. 算法思想

​		首先将存放在L[1…n]中的n个元素建成初始堆，由于堆本身的特点（以大根堆为例），堆顶元素就是最大值。输出堆顶元素后，通常将堆底元素送入堆顶，此时根结点已不满足大顶堆的性质，堆被破坏，将堆顶元素向下调整使其继续保持大顶堆的性质，再输出堆顶元素。如此重复，直到堆中仅剩一个元素为止。

3. 建堆：
   1. 按序列顺序构造二叉树
   2. 找到$\lfloor n/2 \rfloor$处，以它为根结点的树进行调整
   3. 找到之前结点的前一个结点，继续调整，一直重复调整过程中要保证已经调整过的堆还是符合规则的

<img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221119104052992.png" alt="image-20221119104052992" style="zoom: 67%;" />

​	输出堆顶元素后，将堆的最后一个元素与堆顶元素交换，此时堆的性质被破坏，需要向下进行筛选。

<img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221119105517998.png" alt="image-20221119105517998" style="zoom:80%;" />

```c
//将以元素k为根的子树调整为大根堆
void HeadAdjust(ElemType A[], int k, int len) {
	A[0] = A[k];							//A[0]暂存子树的根结点
	for (int i = 2 * k; i <= len; i *= 2) {	//沿key较大的子结点向下筛选
		if (i < len && A[i] < A[i + 1])
			i++;							//取key较大的子结点的下标
		if (A[0] >= A[i])break;				//筛选结束
		else {
			A[k] = A[i];					//将A[i]调整到双亲结点上
			k = i;							//修改k值，以继续向下筛选
		}
	}
	A[k] = A[0];							//被筛选结点的值放入最终位置
}
//建立大根堆
void BuildMaxHeap(ElemType A[], int len) {
	for (int i = len / 2; i < 0; i--)		//从i=[n/2]~1，反复调整堆
		HeadAdjust(A, i, len);
}
```

​	建堆时间复杂度：O(n)。调整时间与树高有关。

4. 排序

​	先将待排序列构造为堆，选出堆中最大（或最小）元素即堆顶元素输出堆顶元素输出后，堆底元素送入堆顶，堆的性质被破坏，将堆顶元素向下调整使其再次成堆，反复输出堆顶元素。

```c
//堆排序完整逻辑
void HeapSort(int A[], int len) {
	BuildMaxHeap(A, len);
	for (int i = len; i > 1; i--) {
		swap(A[i], A[1]);
		HeadAdjust(A, 1, i - 1);
	}
}
```

5. 插入

​	先将新结点放在堆的末端，根据大/小根堆的要求，新元素不断“上升”，直到无法继续上升为止。

<img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221119105615276.png" alt="image-20221119105615276" style="zoom:80%;" />

6. 删除

​	被删除元素用表尾（堆底）元素替代。根据大/小根堆的要求，替代元素不断“下坠”，直到无法继续下坠为止。

​	每次“上升”调整只需对比关键字1次；每次“下坠”调整可能需要对比关键字2次，也可能只需对比1次。

7. 性能分析

​	空间复杂度：O(1)；时间复杂度O(nlog~2~n)；建堆时间为O(n)，之后有n-1次向下调整，每次调整复杂度为O(h)。

​	稳定性：不稳定。进行筛选时，有可能把后面相同关键字的元素调整到前面。

​	堆排序适合**关键字较多的情况**。例如，在1亿个数中选出前100个最大值？首先使用一个大小为100的数组，读入前100个数，建立小顶堆，而后依次读入余下的数，若小于堆顶则舍弃，否则用该数取代堆顶并重新调整堆，待数据读取完毕，堆中100个数即为所求。

### 8.4归并排序

1. 算法思想

​	“归并”的含义是将两个或两个以上的有序表组合成一个新的有序表。假定待排序表含有n个记录，则可将其视为n个有序的子表，每个子表的长度为1，然后两两归并，得到$\lceil n/2 \rceil$个长度为2或1的有序表；继续两两归并…如此重复，直到合并成一个长度为n的有序表为止，这种排序方法称为2路归并排序。

<img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221119110647545.png" alt="image-20221119110647545" style="zoom:80%;" />

​	Merge（）的功能是将前后相邻的两个有序表归并为一个有序表。设两段有序表A[1ow...mid]、A[mid+1…high]存放在同一顺序表中的相邻位置，先将它们复制到辅助数组B中。每次从对应B中的两个段取出一个记录进行关键字的比较，将较小者放入A中，当数组B中有一段的下标超出其对应的表长（即该段的所有元素都已复制到A中）时，将另一段中的剩余部分直接复制到A中。算法如下：

```c
//归并排序，表A的两段A[1ow，mid]和A[mid+1，high]各自有序，将它们合并成一个有序表
void Merge(ElemType A[], int low, int mid, int high) {
	//辅助数组B
	ElemType* B = (ElemType*)malloc((high - low + 1) * sizeof(ElemType));
	int i, j, k;
    for(k=low;k<=high;k++)
        B[k]=A[k];								//将A中所有元素复制到B中
	for (i=low,j=mid+1;i<=mid&&j<=high;k++) {	
		if (B[i] <= B[j])						//比较B的左右两段中的元素
			A[k] = B[i++];						//将较小值复制到A中
		else
			A[k] = B[j++];
	}
	while (i <= mid)A[k++] = B[i++];			//若第一个表未检测完，复制
	while (j < high)A[k++] = B[j++];			//若第二个表未检测完，复制
}
```

​	一趟归并排序的操作是，调用$\lceil n/2h \rceil$次算法merge（），将L[1…n]中前后相邻且长度为h的有序段进行两两归并，得到前后相邻、长度为2h的有序段，整个归并排序需要进行$\lceil log_2n \rceil$趟。

​	递归形式的2路归并排序算法是基于分治的，其过程如下。

- 分解：将含有n个元素的待排序表分成各含2个元素的子表，采用2路归并排序算法对两个子表递归地进行排序。
- 合并：合并两个己排序的子表得到排序结果。

```c
void MergeSort(int A[], int low, int high) {
	if (low < high) {
		int mid = (low + high) / 2;			//从中间划分两个子序列
		MergeSort(A, low, mid);				//对左侧子序列进行递归排序
		MergeSort(A, mid + 1, high);		//对右侧子序列进行递归排序
		Merge(A, low, mid, high);			//归并
	}
}
```

2. 性能分析

​	空间复杂度：O(n)；时间复杂度O(nlog~2~n)；每趟归并的时间复杂度为O（n），共需进行$\lceil log_2n \rceil$趟归并。

​	稳定性：稳定。

### 8.5基数排序

1. 算法思想

​	基数排序是按照低位先排序，然后收集再按照高位排序，然后再收集依次类推，直到最高位。

- 将整个关键字拆分为d位（或“组”）
- 按照各个 关键字位 权重递增的次序（如：个、十、百），做d趟“分配”和“收集”，若当前处理的关键字位可能取得r个值，则需要建立r个队列

​	分配：顺序扫描各个元素，根据当前处理的关键字位，将元素插入相应队列。一趟分配耗时O(n)

​	收集：把各个队列中的结点依次出队并链接。一趟收集耗时O(r)

2. 排序过程

![image-20221119112745633](https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221119112745633.png)

3. 性能分析

​	空间复杂度：O(r)，r个辅助队列；时间复杂度O(d(n+r))，d趟分配和收集，分配需要O(n)，收集需要O(r)；

​	稳定性：稳定

4. 擅长处理

​	①数据元素的关键字可以方便地拆分为d组，且d较小

​	②每组关键字的取值范围不大，即r较小

​	③数据元素个数n较大

### 8.6内部排序比较

|   算法种类   |                    时间复杂度                     | 空间复杂度 | 稳定性 | 适用场合          |
| :----------: | :-----------------------------------------------: | :--------: | :----: | ----------------- |
| 直接插入排序 |             最好：O(n) 最坏：O(n^2^)              |    O(1)    |  稳定  | n小;基本有序      |
| 折半插入排序 |             最好：O(n) 最坏：O(n^2^)              |    O(1)    |  稳定  | n很大             |
|   希尔排序   |    依赖增量序列的函数，在特定条件可达O(n^1.3^)    |    O(1)    | 不稳定 | 中等规模,顺序存储 |
|   冒泡排序   |             最好：O(n) 最坏：O(n^2^)              |    O(1)    |  稳定  | n小;基本有序      |
|   快速排序   | 最好：O(nlog~2~n) 最坏：O(n^2^) 平均：O(nlog~2~n) | O(log~2~n) | 不稳定 | n很大             |
| 简单选择排序 |            最好：O(n^2^) 最坏：O(n^2^)            |    O(1)    | 不稳定 | n小,记录信息量大  |
|    堆排序    |        最好：O(nlog~2~n) 最坏：O(nlog~2~n)        |    O(1)    | 不稳定 | n大;求前若干位    |
| 2路归并排序  |        最好：O(nlog~2~n) 最坏：O(nlog~2~n)        |    O(n)    |  稳定  | n很大             |
|   基数排序   |          最好：O(d(n+r)) 最坏：O(d(n+r))          |    O(r)    |  稳定  | 关键字可拆分      |

### 8.7外部排序

#### 8.7.1基本概念

​	因为文件中的记录很多、信息量庞大，无法将整个文件复制进内存中进行排序。因此，需要将待排序的记录存储在外存上，排序时再把数据一部分一部分地调入内存进行排序，在排序过程中需要多次进行内存和外存之间的交换。这种排序方法就称为外部排序。

#### 8.7.2外部归并排序

1. 时间代价：主要考虑访问磁盘的I/O次数。

2. 归并排序法

   方法：

   ①根据内存缓冲区大小，将外存上的文件分成若干长度为$l$的子文件，依次读入内存并利用内部排序方法对它们进行排序，并将排序后得到的有序子文件重新写回外存，称这些有序子文件为归并段或顺串；

   ②对这些归并段进行逐趟归并，使归并段（有序子文件）逐渐由小到大，直至得到整个有序文件为止。

​		时间代价：$外部排序的总时间=内部排序所需的时间+外存信息读写的时间+内部归并所需的时问$

<img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221119150209706.png" alt="image-20221119150209706" style="zoom:80%;" />

​	一般地，对个初始归并段，做k路平衡归并，归并树可用严格k叉树（即只有度为k与度为0的结点的k叉树）来表示。第一趟可将r个初始归并段归并为$\lceil r/k \rceil$个归并段，以后每趟归并将m个归并段归并成$\lceil m/k \rceil$个归并段，直至最后形成一个大的归并段为止。树的高度-1=$\lceil log_kr \rceil$=归并趟数S。

​	增大归并路数k，或减少初始归并段个数，都能减少归并趟数S，进而减少读写磁盘的次数，达到提高外部排序速度的目的。

#### 8.7.3败者树

​	增加归并路数k时，内部归并的时间将增加。为了使内部归并不受k的增大的影响，引入了败者树。

1. 败者树定义

​	败者树是树形选择排序的一种变体，可视为一棵完全二叉树。k个叶结点分别存放k个归并段在归并过程中当前参加比较的记录，内部结点用来记忆左右子树中的“失败者”，而让胜者往上继续进行比较，一直到根结点。若比较两个数，大的为失败者、小的为胜利者，则根结点指向的数为最小数。

<img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221119150716554.png" alt="image-20221119150716554" style="zoom: 67%;" />

​	使用败者树后，内部归并的比较次数与k无关。因此，只要内存空间允许，增大归并路数k将有效地减少归并树的高度，从而减少/O次数，提高外部排序的速度。

​	归并路数k并不是越大越好。归并路数k增大时，相应地需要增加输入缓冲区的个数。若可供使用的内存空间不变，势必要减少每个输入缓冲区的容量，使得内存、外存交换数据的次数增大。当k值过大时，虽然归并趟数会减少，但读写外存的次数仍会增加。

#### 8.7.4置换-选择排序

1. 目标：产生更长的初始归并段，让初始归并段尽可能的少。

2. 步骤

   设初始待排文件为FI，初始归并段输出文件为FO，内存工作区为WA，FO和WA的初始状态为空，WA可容纳w个记录。置换-选择算法的步骤如下：

   1）从FI输入w个记录到工作区WA。
   2）从WA中选出其中关键字取最小值的记录，记为MINIMAX记录。
   3）将MINIMAX记录输出到FO中去。
   4）若FI不空，则从FI输入下一个记录到WA中。
   5）从WA中所有关键字比MINIMAX记录的关键字大的记录中选出最小关键字记录，作为新的MINIMAXT记录。
   6）重复3）~5），直至在WA中选不出新的MINIMAX记录为止，由此得到一个初始归并段，输出一个归并段的结束标志到「O中去。
   7）重复2）~6），直至WA为空。由此得到全部初始归并段。

<img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221119151700059.png" alt="image-20221119151700059" style="zoom:50%;" />

#### 8.7.5最佳归并树

​	文件经过置换-选择排序后，得到的是长度不等的初始归并段。

​	归并树的WPL=树中所有叶结点的带权路径长度之和
​	将哈夫曼树的思想推广到m叉树的情形，在归并树中，让记录数少的初始归并段最先归并，记录数多的初始归并段最晚归并，就可以建立总的I/O次数最少的最佳归并树。

<img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221119152236539.png" alt="image-20221119152236539" style="zoom:50%;" />

​	算法思想：补充虚段，若初始归并段不足以构成一棵严格k叉树时，需添加长度为0的“虚段”，按照哈夫曼树的原则，权为0的叶子应离树根最远。

​	设度为0的结点有n~0~(=n)个，度为k的结点有n~k~个，则对严格k叉树有n~0~=(k-1)n~k~+1，由此可得n~k~=(n~0~-1）/(k-1)。

- ①若（初始归并段数量-1）%（k-1）=0，说明刚好可以构成严格k叉树，此时不需要添加虚段
- ②若（初始归并段数量-1）%（k-1）=u≠0，则需要补充$k-u-1$个虚段

<img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20221119152932394.png" alt="image-20221119152932394" style="zoom:67%;" />
